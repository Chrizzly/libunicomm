<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tutorial_page.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul style="list-style-type:none;">
<li>
<a class="el" href="tutorial_page.html#basics_section">Basics</a> </li>
<li>
<a class="el" href="tutorial_page.html#sessions_section">Sessions</a> </li>
<li>
<a class="el" href="tutorial_page.html#config_section">Configuration</a> </li>
</ul>
<h1><a class="anchor" id="basics_section"></a>
Basics</h1>
<p>There are several entities involved to provide the functionality you should know to use unicomm.</p>
<dl class="section user"><dt>Messages</dt><dd>Messages are objects that the communication sites send each other. Messages can be serialized and deserialized. Base class for the messages is <a class="el" href="classunicomm_1_1message__base.html" title="Unicomm message base class.">unicomm::message_base</a>. In most cases it's just necessary to override two virtual members to provide the serialization of custom data fields. There are also predefined facade message classes that allow to transfer either binary or XML data using built-in XML engine. If you wish to use your own message format (decoding/encoding), you should also implement decoder/encoder entities: <a class="el" href="classunicomm_1_1message__decoder__base.html" title="Unicomm message decoder base class.">unicomm::message_decoder_base</a>, <a class="el" href="classunicomm_1_1message__encoder__base.html" title="Unicomm message encoder class.">unicomm::message_encoder_base</a>.</dd></dl>
<dl class="section user"><dt>Sessions </dt><dd>The session is an object that created when connect occurs and destroyed on disconnect. Session provides number of virtual functions that receive different communication events. Like message arrived, message sent, message timeout and etc. Base classes for session are <a class="el" href="classunicomm_1_1session__base.html" title="Session interface which should be implemented by user&#39;s code to receive event notifications.">unicomm::session_base</a>, <a class="el" href="classunicomm_1_1basic__session.html" title="Session interface to be implemented by user&#39;s code to receive event notifications.">unicomm::basic_session</a> or <a class="el" href="classunicomm_1_1extended__session.html" title="Session class which allows to map callable objects to events.">unicomm::extended_session</a> (<a class="el" href="faq_page.html#which_session_to_use_section">Which one to use</a>?).</dd></dl>
<dl class="section user"><dt>Communicator</dt><dd>Communication is provided by <a class="el" href="classunicomm_1_1communicator.html" title="TCP communication service.">unicomm::communicator</a>. Communicator object associated with the session that is accessible through the handler parameters of the session. Communicator provides information about the connection and also provides control over the connection such as disconnect and send services. Each instance of <a class="el" href="classunicomm_1_1communicator.html" title="TCP communication service.">unicomm::communicator</a> has an unique <em>identifier</em>. As communicator represents the connection, connection has an id. This id is mentioned in this manual as connection id, comm id and communicator id, session id. Those are the same.</dd></dl>
<dl class="section user"><dt>Dispatcher (Server, Client)</dt><dd>In most it's enough to use <a class="el" href="classunicomm_1_1server.html" title="Unicomm server.">unicomm::server</a> and <a class="el" href="classunicomm_1_1client.html" title="Unicomm client.">unicomm::client</a> as is. The only difference between server and client is that client can initiate connections and server can accept connections. To start working it's necessary to execute <a class="el" href="classunicomm_1_1dispatcher.html#a52ea99895975a2019246877bae490dac" title="Main dispatcher&#39;s loop.">unicomm::dispatcher::run()</a>. There is no background threads are used. The context (thread) of the execution shoould be provided by the user. Then it's necessary to call <a class="el" href="classunicomm_1_1server.html#adc926c1b0dfef739d9922a3b59dd89b1" title="Tells the underlying logic to perform one accept operation on the socket.">unicomm::server::accept()</a> or <a class="el" href="classunicomm_1_1client.html#aac5c26bb04508204d4bd41e83d7ce4ea" title="Request to connect using endpoint which is set on constructor or previous connect call...">unicomm::client::connect()</a> to start the communication process.</dd></dl>
<dl class="section user"><dt>Configuration</dt><dd>Server and client should be configured before they can be used. It's necessary to provide factory methods for certain entities and other stuff to unicomm. Configuration binds the above stuff together. On how to create configuration object please inspect <a class="el" href="examples_page.html">examples</a>.</dd></dl>
<h1><a class="anchor" id="sessions_section"></a>
Sessions</h1>
<p>The meaning of the unicomm session is traditional. The session can be only considered as valid while the connection is established, when the connection breaks the session becomes invalid and must not be used. Note that if you create a reference or pointer to the session object, after disconnect occurs the access to the session through those will lead to the memory access violation i.e. to std::terminate() eventually. The session lifetime is determined by connected and disconnected handlers.</p>
<p>In common way to invoke upper (business) logic it's necessary to inherit from either <a class="el" href="classunicomm_1_1session__base.html" title="Session interface which should be implemented by user&#39;s code to receive event notifications.">unicomm::session_base</a>, <a class="el" href="classunicomm_1_1basic__session.html" title="Session interface to be implemented by user&#39;s code to receive event notifications.">unicomm::basic_session</a> or <a class="el" href="classunicomm_1_1extended__session.html" title="Session class which allows to map callable objects to events.">unicomm::extended_session</a> and override necessary functions or assign handlers (In case of <a class="el" href="classunicomm_1_1extended__session.html" title="Session class which allows to map callable objects to events.">unicomm::extended_session</a>).</p>
<p>There is no matter what side (server/client) the connection occurs on. Everything is described relates to both server and client classes. When connection occurs, either accepted by server or initiated by client connect is succeeded, at first, session constructor is called. It also as <a class="el" href="classunicomm_1_1session__base.html#a1ada5f3f3bc53c7502b8a878e455a9b9" title="Connected handler.">unicomm::session_base::connected_handler</a> accepts <a class="el" href="classunicomm_1_1connected__params.html" title="Connected handler parameters.">unicomm::connected_params</a>. Any exception from user's session object constructor will brake the connection immediately and destroy the parent communication object which tries to create user's session object. After constructor completed <a class="el" href="classunicomm_1_1session__base.html#a1ada5f3f3bc53c7502b8a878e455a9b9" title="Connected handler.">unicomm::session_base::connected_handler</a> is called.</p>
<p>When disconnect occurs the <a class="el" href="classunicomm_1_1session__base.html#a3b3a5607df49266e2979de9c82e84e80" title="Disconnected handler.">unicomm::session_base::disconnected_handler</a> is invoked. After it completes session object is destroyed, so destructor is called immediately after the disconnected handler. Most of handlers allow exception to be thrown within the handler. For more details see <a class="el" href="tutorial_page.html#events_subsection">session events</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classunicomm_1_1session__base.html" title="Session interface which should be implemented by user&#39;s code to receive event notifications.">unicomm::session_base</a>, <a class="el" href="classunicomm_1_1basic__session.html" title="Session interface to be implemented by user&#39;s code to receive event notifications.">unicomm::basic_session</a>, <a class="el" href="classunicomm_1_1extended__session.html" title="Session class which allows to map callable objects to events.">unicomm::extended_session</a> (<a class="el" href="faq_page.html#which_session_to_use_section">Which one to use</a>?).</dd></dl>
<h2><a class="anchor" id="events_subsection"></a>
Session events</h2>
<p>There are several events defined. Each event handler accepts parameters. Handler parameters structure depends on handler type the parameters regards to. Every parameters structure except <a class="el" href="classunicomm_1_1connect__error__params.html" title="Connection failure parameters class.">unicomm::connect_error_params</a> and <a class="el" href="classunicomm_1_1after__all__processed__params.html" title="After all processed parameters class.">unicomm::after_all_processed_params</a> has reference to the instance of <a class="el" href="classunicomm_1_1communicator.html" title="TCP communication service.">unicomm::communicator</a> that is responsible for the communication of this session. The communication object is used to manipulate the connection and get the information such as local and remote endpoints. It allows to send messages and perform disconnect.</p>
<dl class="section note"><dt>Note</dt><dd>Almost all the handlers allow to throw any exceptions. But note that debug will assert if the thrown exception is not <b>std::exception</b> derived, release does nothing. <b>If any specific restrictions exist for certain handler, it is explicitly specified.</b> Throwing an exception from the handler where it allowed interrupts unicomm::communicator::process() at the current iteration and moves to next <a class="el" href="classunicomm_1_1communicator.html" title="TCP communication service.">unicomm::communicator</a> to be processed. Throwing <a class="el" href="classunicomm_1_1disconnected__error.html" title="Disconnected error exception.">unicomm::disconnected_error</a> leads to connection braking.</dd></dl>
<ul style="list-style-type:none;">
<li>
<p class="startli"><a class="el" href="classunicomm_1_1session__base.html#a1ada5f3f3bc53c7502b8a878e455a9b9">Connected event</a>. The event occurs only if connect is succeeded or incoming connection accepted successfully. It also regards to ssl handshakes. Handshake is transparent for user's code. Session is only created if every operation during the connect is successfully completed.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classunicomm_1_1session__base.html#a3b3a5607df49266e2979de9c82e84e80">Disconnected event</a> <b>NO THROW</b>. The event occurs on disconnect. It means when handler is invoked the communication is already stopped and tcp socket is closed. Parameters have the reason of the connection closure. The session's destructor is called immediately after this handler completes.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classunicomm_1_1session__base.html#a50edfca3363140e90e56c5588783d277">Message arrived event</a>. Occurs when message is received by transport layer and successfully parsed.</p>
<p class="endli"></p>
</li>
<li>
<a class="el" href="classunicomm_1_1session__base.html#abc5101807be9da2c8c82897b7b4946c7">Message sent event</a>. The event happens when the message is actually sent. The event's parameters contain the identifier of the message has been sent. <dl class="section see"><dt>See Also</dt><dd><a class="el" href="classunicomm_1_1dispatcher.html#afe9bca24bce4690e9a524acb4930e4e7" title="Sends a message to the remote side of the connection with the given id.">unicomm::dispatcher::send_one()</a>, <a class="el" href="classunicomm_1_1dispatcher.html#a4aefc031533f4e18e22e5191658a43da" title="Sends a message to the remote sides of all currently opened connections.">unicomm::dispatcher::send_all()</a>, <a class="el" href="namespaceunicomm.html#aef3322107167b41bb771a17061f9630c" title="Sends given message to the specified client.">unicomm::send_one()</a>, <a class="el" href="namespaceunicomm.html#a3f56723d000eaa1a20f187e1549505bd" title="Sends given message to all currently connected clients.">unicomm::send_all()</a>.</dd></dl>
</li>
<li>
<p class="startli"><a class="el" href="classunicomm_1_1session__base.html#a386586ebd83231c95f672f89a5f41f80">Message timeout event</a>. The event occurs if the reply for the sent message is not got within timeout specified by the configuration for this message type. If the timeouted message comes after the timeout period elapsed it is thrown out and it is not reported i.e. message arrived handler is not called.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><a class="el" href="classunicomm_1_1session__base.html#ad58444e0ef3afe760830ab3a6a6404eb">Error event</a> <b>NO THROW</b>. Error handler invoked when any exception is risen while processing. For instance, if any user handler (except error handler, disconnect handler) rises an exception the error handler will be invoked. If description is available it will be accessible through second parameter. Must be <b>no throw</b>. Debug asserts on throw, release does nothing.</p>
<p class="endli"></p>
</li>
<li>
<a class="el" href="classunicomm_1_1session__base.html#a0664f12d12fdfca75658adc87cecac41">After processed event</a>. Occurs when current communication process (unicomm::communicator::process()) iteration finishes successfully. </li>
</ul>
<p>Following events have no reference to <a class="el" href="classunicomm_1_1communicator.html" title="TCP communication service.">unicomm::communicator</a>.</p>
<ul style="list-style-type:none;">
<li>
<p class="startli"><a class="el" href="namespaceunicomm.html#a56a16c22a46f345214fceea904ebbdb0">Connect error event</a> <b>NO THROW</b>. If an error occurs while initiating connection on client side connect error handler is called.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classunicomm_1_1client.html#a831a0714d298ebdaa8c0ca412dae628c" title="Adds connection failure handler.">unicomm::client::add_connect_error_handler()</a>.</dd></dl>
</li>
<li>
<p class="startli"><a class="el" href="namespaceunicomm.html#a5918e124615be2e694c3a09a5dd62625">After all processed event</a>. The event occurs each time when the process iteration is about to finish. The handler is called after all the communication objects are processed. So, if there are no connections this handler is called within the <a class="el" href="classunicomm_1_1config.html#aa6d08417b848fe225e38b825cc9ea773" title="Returns unicomm working thread sleep timeout.">unicomm::config::dispatcher_idle_tout()</a> period.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="classunicomm_1_1dispatcher.html#ad5c8b1cd7ce9803956abf372f03a5ff8" title="Sets after processed handler.">unicomm::dispatcher::set_after_all_processed_handler()</a>, <a class="el" href="classunicomm_1_1dispatcher.html#a031745369669fa992f69cd7c47f275a7" title="Clears after all processed handler.">unicomm::dispatcher::clear_after_all_processed_handler</a>.</dd></dl>
</li>
</ul>
<h1><a class="anchor" id="config_section"></a>
Configuration</h1>
<p>Configuration object holds parameters that determine the behaviour, also it holds factory methods to make the construction of the sessions and messages to be possible. The most of parameters are optional like message timeouts and priority. By default <a class="el" href="namespaceunicomm.html#aec77fe06792bf10e9c5e1117c7220262" title="Infinite timeout value.">unicomm::infinite_timeout()</a> and <a class="el" href="namespaceunicomm.html#a065ef7fa505f9dfe59676596e4900203" title="Undefined priority value.">unicomm::undefined_priority()</a> values are used.</p>
<p>To find out details on unicomm parameters please see the <a class="el" href="classunicomm_1_1config.html" title="Unicomm configuration storage class.">unicomm::config</a> reference.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="examples_page.html">Examples</a> </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Jun 1 2013 01:38:54 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.2 </li>
  </ul>
</div>
</body>
</html>
