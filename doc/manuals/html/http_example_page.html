<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Http</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('http_example_page.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Http </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Before read this example it's recommended to read <a class="el" href="term_example_page.html">term</a> or <a class="el" href="echo_example_page.html">echo</a> example first. This example contains a lot of http specific stuff that complicate the understanding of the approach. Conceptually this sample is the same as mentioned above. </p>
<p>This sample is closer to real world application. It provides an explanation on how to use unicomm in real world applications. The only basics of http is implemented. </p>
<h1><a class="anchor" id="http_messages_section"></a>
Messages</h1>
<p>We define base class for http message inherited from <a class="el" href="classunicomm_1_1message__base.html" title="Unicomm message base class.">unicomm::message_base</a>.</p>
 <div class="fragment"><div class="line"><span class="keyword">struct </span>message_base : <span class="keyword">public</span> <a class="code" href="classunicomm_1_1message__base.html" title="Unicomm message base class.">unicomm::message_base</a></div>
<div class="line">{</div>
<div class="line"><span class="comment">// interface</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> message_base(<span class="keyword">const</span> std::string&amp; data): </div>
<div class="line">    _data(data) </div>
<div class="line">  { </div>
<div class="line">    <span class="comment">// empty</span></div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  message_base&amp; add_header(<span class="keyword">const</span> std::string&amp; name, <span class="keyword">const</span> std::string&amp; value);</div>
<div class="line">  message_base&amp; remove_header(<span class="keyword">const</span> std::string&amp; name);</div>
<div class="line">  <span class="keyword">const</span> std::string&amp; get_header(<span class="keyword">const</span> std::string&amp; name) <span class="keyword">const</span>;</div>
<div class="line">  <span class="keywordtype">void</span> clear_headers(<span class="keywordtype">void</span>);</div>
<div class="line">  std::string headers_str(<span class="keywordtype">void</span>) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">const</span> std::string&amp; data(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _data; }</div>
<div class="line">  <span class="keywordtype">void</span> data(<span class="keyword">const</span> std::string&amp; s) { _data = s; }</div>
<div class="line"></div>
<div class="line">  std::string serialize(<span class="keywordtype">void</span>) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> unserialize(<span class="keyword">const</span> std::string &amp;message);</div>
<div class="line"></div>
<div class="line"><span class="comment">// private stuff</span></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">virtual</span> std::string serialize_first_str(<span class="keywordtype">void</span>) <span class="keyword">const</span> = 0;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> unserialize_first_str(<span class="keyword">const</span> std::string &amp;message) = 0;</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  header::header_collection_type _headers;</div>
<div class="line">  std::string _data;</div>
<div class="line">};</div>
</div><!-- fragment --></p>
<p>Then define http request and response classes.</p>
<h2><a class="anchor" id="http_request_subsection"></a>
Request</h2>
 <div class="fragment"><div class="line"><span class="keyword">struct </span>request : <span class="keyword">public</span> message_base</div>
<div class="line">{</div>
<div class="line"><span class="comment">// interface</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">typedef</span> boost::shared_ptr&lt;request&gt; pointer_type;</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> std::string&amp; <span class="keyword">get</span>(void) </div>
<div class="line">    { <span class="keyword">static</span> <span class="keyword">const</span> std::string s  = <span class="stringliteral">&quot;GET&quot;</span>; <span class="keywordflow">return</span> s; }</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> std::string&amp; post(<span class="keywordtype">void</span>) </div>
<div class="line">    { <span class="keyword">static</span> <span class="keyword">const</span> std::string s = <span class="stringliteral">&quot;POST&quot;</span>; <span class="keywordflow">return</span> s; }</div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> std::string&amp; head(<span class="keywordtype">void</span>) </div>
<div class="line">    { <span class="keyword">static</span> <span class="keyword">const</span> std::string s = <span class="stringliteral">&quot;HEAD&quot;</span>; <span class="keywordflow">return</span> s; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> request(<span class="keyword">const</span> std::string&amp; request_name = <span class="stringliteral">&quot;&quot;</span>, </div>
<div class="line">                   <span class="keyword">const</span> std::string&amp; uri = <span class="stringliteral">&quot;&quot;</span>, </div>
<div class="line">                   <span class="keyword">const</span> std::string&amp; data = <span class="stringliteral">&quot;&quot;</span>): </div>
<div class="line">    message_base(data),</div>
<div class="line">    _name(request_name),</div>
<div class="line">    _uri(uri)</div>
<div class="line">  { </div>
<div class="line">    <span class="comment">// empty</span></div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">const</span> std::string&amp; name(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _name; }</div>
<div class="line">  <span class="keyword">const</span> std::string&amp; uri(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _uri; }</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> name(<span class="keyword">const</span> std::string&amp; s) { _name = s; }</div>
<div class="line">  <span class="keywordtype">void</span> uri(<span class="keyword">const</span> std::string&amp; s) { _uri = s; }</div>
<div class="line"></div>
<div class="line"><span class="comment">// private stuff</span></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="comment">/*virtual*/</span> std::string serialize_first_str(<span class="keywordtype">void</span>) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">  <span class="comment">/*virtual*/</span> <span class="keywordtype">void</span> unserialize_first_str(<span class="keyword">const</span> std::string &amp;s);</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  std::string _name;</div>
<div class="line">  std::string _uri;</div>
<div class="line">};</div>
</div><!-- fragment --></p>
<h2><a class="anchor" id="http_response_subsection"></a>
Response</h2>
 <div class="fragment"><div class="line"><span class="keyword">struct </span>response : <span class="keyword">public</span> message_base</div>
<div class="line">{</div>
<div class="line"><span class="comment">// interface</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">typedef</span> boost::shared_ptr&lt;response&gt; pointer_type;</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> response(<span class="keyword">const</span> std::string&amp; status_code = status_code::ok(),</div>
<div class="line">                    <span class="keyword">const</span> std::string&amp; data = <span class="stringliteral">&quot;&quot;</span>): </div>
<div class="line">    message_base(data),</div>
<div class="line">    _status_code(status_code)</div>
<div class="line">  { </div>
<div class="line">    <span class="comment">// empty</span></div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">const</span> std::string&amp; name(<span class="keywordtype">void</span>)<span class="keyword"> const </span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keyword">static</span> <span class="keyword">const</span> std::string s = <span class="stringliteral">&quot;&quot;</span>; <span class="keywordflow">return</span> s; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">const</span> std::string&amp; status_code(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _status_code; }</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> status_code(<span class="keyword">const</span> std::string&amp; s) { _status_code = s; }</div>
<div class="line"></div>
<div class="line"><span class="comment">// private stuff</span></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="comment">/*virtual*/</span> std::string serialize_first_str(<span class="keywordtype">void</span>) <span class="keyword">const</span>;</div>
<div class="line"></div>
<div class="line">  <span class="comment">/*virtual*/</span> <span class="keywordtype">void</span> unserialize_first_str(<span class="keyword">const</span> std::string &amp;s);</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  std::string _status_code;</div>
<div class="line">};</div>
</div><!-- fragment --></p>
<h1><a class="anchor" id="http_session_params_section"></a>
Session parameters</h1>
<h2><a class="anchor" id="http_client_session_params_subsection"></a>
Client</h2>
<p>Client parameters holds only connected handler.</p>
 <div class="fragment"><div class="line"><span class="keyword">struct </span>client_session_params</div>
<div class="line">{</div>
<div class="line"><span class="comment">// interface</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> client_session_params(</div>
<div class="line">      <span class="keyword">const</span> unicomm::connected_signal_type::slot_type&amp; connected_handler):</div>
<div class="line">    _connected_handler(connected_handler)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// empty</span></div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">//--------------------------------------------------------------------</span></div>
<div class="line">  <span class="keyword">const</span> unicomm::connected_signal_type::slot_type&amp; connected_handler(<span class="keywordtype">void</span>)<span class="keyword"> const </span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> _connected_handler; }</div>
<div class="line"></div>
<div class="line"><span class="comment">// private stuff</span></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  unicomm::connected_signal_type::slot_type _connected_handler;</div>
<div class="line">};</div>
</div><!-- fragment --></p>
<h2><a class="anchor" id="http_server_session_params_subsection"></a>
Server</h2>
<p>Server parameters contains server hosts collection, connected and disconnected handlers.</p>
 <div class="fragment"><div class="line"><span class="keyword">struct </span>server_session_params</div>
<div class="line">{</div>
<div class="line"><span class="comment">// interface</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> server_session_params(<span class="keyword">const</span> hosts_collection_type&amp; served_hosts,</div>
<div class="line">    <span class="keyword">const</span> unicomm::connected_signal_type::slot_type&amp; connected_handler,</div>
<div class="line">      <span class="keyword">const</span> unicomm::disconnected_signal_type::slot_type&amp; disconnected_handler):</div>
<div class="line">    _served_hosts(served_hosts),</div>
<div class="line">    _connected_handler(connected_handler),</div>
<div class="line">    _disconnected_handler(disconnected_handler)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// empty</span></div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">//--------------------------------------------------------------------</span></div>
<div class="line">  <span class="keyword">const</span> hosts_collection_type&amp; served_hosts(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _served_hosts; }</div>
<div class="line">  <span class="keyword">const</span> unicomm::connected_signal_type::slot_type&amp; connected_handler(<span class="keywordtype">void</span>)<span class="keyword"> const </span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> _connected_handler; }</div>
<div class="line">  <span class="keyword">const</span> unicomm::disconnected_signal_type::slot_type&amp; disconnected_handler(<span class="keywordtype">void</span>)<span class="keyword"> const </span></div>
<div class="line"><span class="keyword">    </span>{ <span class="keywordflow">return</span> _disconnected_handler; }</div>
<div class="line"></div>
<div class="line"><span class="comment">// private stuff</span></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  hosts_collection_type _served_hosts;</div>
<div class="line">  unicomm::connected_signal_type::slot_type _connected_handler;</div>
<div class="line">  unicomm::disconnected_signal_type::slot_type _disconnected_handler;</div>
<div class="line">};</div>
</div><!-- fragment --></p>
<h1><a class="anchor" id="http_session_section"></a>
Session</h1>
<p>Note that the session is not an http session. This is the <a class="el" href="classunicomm_1_1extended__session.html" title="Session class which allows to map callable objects to events.">unicomm::extended_session</a> descendant that representes the connection. The session in http meaning is not defined here, it can be easily added if necessary as upper level logic that will share several connections at a time. We are not going to implement another http server, but just want to show what can be done by using unicomm.</p>
<h2><a class="anchor" id="http_session_base_subsection"></a>
Base session</h2>
<p>We define base class for the session.</p>
 <div class="fragment"><div class="line"><span class="comment">// In this example uni_http::session_base is only prints an information</span></div>
<div class="line"><span class="comment">// to the std::cout.</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> DerivedT, <span class="keyword">typename</span> SessionParamsT&gt;</div>
<div class="line"><span class="keyword">class </span>session_base : <span class="keyword">public</span> <a class="code" href="classunicomm_1_1extended__session.html" title="Session class which allows to map callable objects to events.">unicomm::extended_session</a>&lt;DerivedT, SessionParamsT&gt;</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">typedef</span> <a class="code" href="classunicomm_1_1extended__session.html" title="Session class which allows to map callable objects to events.">unicomm::extended_session&lt;DerivedT, SessionParamsT&gt;</a> <a class="code" href="classunicomm_1_1basic__session.html#a409bf5d5b419461ffb7b6ce349ceccae" title="Session base type.">base_type</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// interface</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> session_base(<span class="keyword">const</span> SessionParamsT&amp; session_params):</div>
<div class="line">    base_type(session_params)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// NOTE:</span></div>
<div class="line">    <span class="comment">// If it&#39;s necessary to close connection when it is just </span></div>
<div class="line">    <span class="comment">// established throw any exception from session constructor. </span></div>
<div class="line">    <span class="comment">// Connection will be closed and session won&#39;t be created. Throwing </span></div>
<div class="line">    <span class="comment">// disconnect_error from connection_handler causes session </span></div>
<div class="line">    <span class="comment">// disconnects too. Usual way to disconnect a session is to call </span></div>
<div class="line">    <span class="comment">// communicator::disconnect() from any handler defined by the session.</span></div>
<div class="line">    <span class="comment">// It would be like (inside one of the session handlers scope): </span></div>
<div class="line">    <span class="comment">// params.comm().disconnect();</span></div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="comment">// virtual functions</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Override handlers in base class to out some information.</span></div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classunicomm_1_1extended__session.html#ad8ce76a30a979befcd79a022220a1b16" title="Connected handler.">connected_handler</a>(<span class="keyword">const</span> <a class="code" href="classunicomm_1_1connected__params.html" title="Connected handler parameters.">unicomm::connected_params</a>&amp; params)</div>
<div class="line">  {</div>
<div class="line">    std::stringstream ss;</div>
<div class="line"></div>
<div class="line">    ss &lt;&lt; name() &lt;&lt; <span class="stringliteral">&quot;: [&quot;</span> &lt;&lt; params.<a class="code" href="classunicomm_1_1params__base.html#af45141bb3d78dc963d19a6c8151ac716" title="Returns an object responsible for communication.">comm</a>().<a class="code" href="classunicomm_1_1communicator.html#a3e9aecebccde08dd624835ee458b46f7" title="Returns current object identifier.">id</a>() &lt;&lt; <span class="stringliteral">&quot;]: connected; local endpoint: &quot;</span></div>
<div class="line">      &lt;&lt; params.<a class="code" href="classunicomm_1_1params__base.html#af45141bb3d78dc963d19a6c8151ac716" title="Returns an object responsible for communication.">comm</a>().<a class="code" href="classunicomm_1_1communicator.html#a0e6fc78c1d19433df3e4274d9443a9eb" title="Returns local endpoint of the established connection.">local_endpoint</a>() &lt;&lt; <span class="stringliteral">&quot;, remote endpoint: &quot;</span></div>
<div class="line">      &lt;&lt; params.<a class="code" href="classunicomm_1_1params__base.html#af45141bb3d78dc963d19a6c8151ac716" title="Returns an object responsible for communication.">comm</a>().<a class="code" href="classunicomm_1_1communicator.html#a9ce6711b1ff9ac445c3db3ce9267b9e9" title="Returns remote endpoint that the communicator is connected to.">remote_endpoint</a>();</div>
<div class="line">    out_str(ss.str());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// dispatch further</span></div>
<div class="line">    base_type::connected_handler(params);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classunicomm_1_1extended__session.html#a802435a754be295db575ed4baad0f8d8" title="Disconnected handler.">disconnected_handler</a>(<span class="keyword">const</span> <a class="code" href="classunicomm_1_1disconnected__params.html" title="Disconnected handler parameters.">unicomm::disconnected_params</a>&amp; params)</div>
<div class="line">  {</div>
<div class="line">    std::stringstream ss;</div>
<div class="line"></div>
<div class="line">    ss &lt;&lt; name() &lt;&lt; <span class="stringliteral">&quot;: [&quot;</span> &lt;&lt; params.<a class="code" href="classunicomm_1_1params__base.html#af45141bb3d78dc963d19a6c8151ac716" title="Returns an object responsible for communication.">comm</a>().<a class="code" href="classunicomm_1_1communicator.html#a3e9aecebccde08dd624835ee458b46f7" title="Returns current object identifier.">id</a>() &lt;&lt; <span class="stringliteral">&quot;]: disconnected; &quot;</span></div>
<div class="line">      &lt;&lt; params.<a class="code" href="classunicomm_1_1disconnected__params.html#a2b7ce786a59652170db257d25d85c973" title="Returns a disconnected reason.">error_code</a>() &lt;&lt; <span class="stringliteral">&quot;; &quot;</span> &lt;&lt; params.<a class="code" href="classunicomm_1_1disconnected__params.html#a861486491dae14352b0b0d49fc23542f" title="Returns a disconnected reason string.">what</a>();</div>
<div class="line">    out_str(ss.str());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// dispatch further</span></div>
<div class="line">    base_type::disconnected_handler(params);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classunicomm_1_1extended__session.html#a986828dda873b407eba4a597bd360fd8" title="Message timeout handler.">message_timeout_handler</a>(<span class="keyword">const</span> <a class="code" href="classunicomm_1_1message__sent__params.html" title="Message sent handler parameters.">unicomm::message_timeout_params</a>&amp; params)</div>
<div class="line">  {</div>
<div class="line">    std::stringstream ss;</div>
<div class="line"></div>
<div class="line">    ss &lt;&lt; name() &lt;&lt; <span class="stringliteral">&quot;: [&quot;</span> &lt;&lt; params.<a class="code" href="classunicomm_1_1params__base.html#af45141bb3d78dc963d19a6c8151ac716" title="Returns an object responsible for communication.">comm</a>().<a class="code" href="classunicomm_1_1communicator.html#a3e9aecebccde08dd624835ee458b46f7" title="Returns current object identifier.">id</a>()</div>
<div class="line">      &lt;&lt; <span class="stringliteral">&quot;]: other side didn&#39;t reply within timeout, message id: &quot;</span></div>
<div class="line">      &lt;&lt; params.<a class="code" href="classunicomm_1_1message__sent__params.html#a39e3d31bfff1fdd8e072b6071d284954" title="Returns a sent message&#39;s identifier.">message_id</a>();</div>
<div class="line">    out_str(ss.str());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// dispatch further</span></div>
<div class="line">    base_type::message_timeout_handler(params);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="classunicomm_1_1extended__session.html#a936cd1363cdad388e8da738465409dc7" title="Error handler.">error_handler</a>(<span class="keyword">const</span> <a class="code" href="classunicomm_1_1error__params.html" title="Error handler parameters.">unicomm::error_params</a>&amp; params)</div>
<div class="line">  {</div>
<div class="line">    std::stringstream ss;</div>
<div class="line"></div>
<div class="line">    ss &lt;&lt; name() &lt;&lt; <span class="stringliteral">&quot;: [&quot;</span> &lt;&lt; params.<a class="code" href="classunicomm_1_1params__base.html#af45141bb3d78dc963d19a6c8151ac716" title="Returns an object responsible for communication.">comm</a>().<a class="code" href="classunicomm_1_1communicator.html#a3e9aecebccde08dd624835ee458b46f7" title="Returns current object identifier.">id</a>()</div>
<div class="line">      &lt;&lt; <span class="stringliteral">&quot;]: an error occurred, error: &quot;</span> &lt;&lt; params.<a class="code" href="classunicomm_1_1error__params.html#a941ed1ac99cc26b5cd02055a854f352c" title="Returns an error description.">description</a>();</div>
<div class="line">    out_str(ss.str());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// dispatch further</span></div>
<div class="line">    base_type::error_handler(params);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"><span class="keyword">protected</span>:</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; name(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> session_name(*<span class="keyword">this</span>); }</div>
<div class="line">};</div>
</div><!-- fragment --></p>
<h2><a class="anchor" id="http_client_session_subsection"></a>
Client</h2>
<p>The definition of client's session is quite simple.</p>
 <div class="fragment"><div class="line"><span class="keyword">class </span>client_session : <span class="keyword">public</span> session_base&lt;client_session, client_session_params&gt;</div>
<div class="line">{</div>
<div class="line"><span class="comment">// interface</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">typedef</span> uni_http::session_base&lt;client_session, client_session_params&gt; base_type;</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> client_session(<span class="keyword">const</span> <a class="code" href="classunicomm_1_1connected__params.html" title="Connected handler parameters.">unicomm::connected_params</a>&amp; params,</div>
<div class="line">                          <span class="keyword">const</span> session_params_type&amp; session_params):</div>
<div class="line">    base_type(session_params),</div>
<div class="line">    _in_buffer(&amp;params.in_buffer())</div>
<div class="line">  {</div>
<div class="line">    add_connected_handler(session_params.connected_handler());</div>
<div class="line">    add_disconnected_handler(boost::bind(&amp;client_session::disconnected_handler_1, <span class="keyword">this</span>, _1));</div>
<div class="line">    set_message_timeout_handler(boost::bind(&amp;client_session::message_timeout_handler_1, <span class="keyword">this</span>, _1));</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">bool</span> is_server(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">false</span>; }</div>
<div class="line"></div>
<div class="line"><span class="comment">// private stuff</span></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="comment">// assigned handlers</span></div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> message_timeout_handler_1(<span class="keyword">const</span> <a class="code" href="classunicomm_1_1message__sent__params.html" title="Message sent handler parameters.">unicomm::message_timeout_params</a>&amp; params);</div>
<div class="line">  <span class="keywordtype">void</span> disconnected_handler_1(<span class="keyword">const</span> <a class="code" href="classunicomm_1_1disconnected__params.html" title="Disconnected handler parameters.">unicomm::disconnected_params</a>&amp; params);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// virtual functions</span></div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> message_arrived_handler(<a class="code" href="classunicomm_1_1message__arrived__params.html" title="Message arrived handler parameters class.">unicomm::message_arrived_params</a>&amp; params);</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <a class="code" href="classunicomm_1_1comm__buffer.html" title="Communicator buffer provides thread safe operations on buffer.">unicomm::comm_buffer</a>* _in_buffer;</div>
<div class="line">};</div>
</div><!-- fragment --></p>
 <div class="fragment"><div class="line"><span class="keywordtype">void</span> uni_http::client_session::message_timeout_handler_1(<span class="keyword">const</span> <a class="code" href="classunicomm_1_1message__sent__params.html" title="Message sent handler parameters.">unicomm::message_timeout_params</a>&amp; params)</div>
<div class="line">{</div>
<div class="line">  params.<a class="code" href="classunicomm_1_1params__base.html#af45141bb3d78dc963d19a6c8151ac716" title="Returns an object responsible for communication.">comm</a>().<a class="code" href="classunicomm_1_1communicator.html#af935e7144a562f8a58269d5f823a803b" title="Brakes the connection.">disconnect</a>();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// another facility to disconnect</span></div>
<div class="line">  <span class="comment">//throw unicomm::disconnected_error(boost::system::error_code(), </span></div>
<div class="line">  <span class="comment">//  &quot;Disconnected due to message timeout&quot;);</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------</span></div>
<div class="line"><span class="keywordtype">void</span> uni_http::client_session::disconnected_handler_1(<span class="keyword">const</span> <a class="code" href="classunicomm_1_1disconnected__params.html" title="Disconnected handler parameters.">unicomm::disconnected_params</a>&amp; <span class="comment">/*params*/</span>)</div>
<div class="line">{</div>
<div class="line">  BOOST_ASSERT(_in_buffer-&gt;empty() &amp;&amp; <span class="stringliteral">&quot; - Buffer should already be empty here&quot;</span>);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// virtual functions</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> uni_http::client_session::message_arrived_handler(<a class="code" href="classunicomm_1_1message__arrived__params.html" title="Message arrived handler parameters class.">unicomm::message_arrived_params</a>&amp; params)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// use the incoming data somehow</span></div>
<div class="line">  <span class="keyword">const</span> response&amp; inm = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>response&amp;<span class="keyword">&gt;</span>(params.<a class="code" href="classunicomm_1_1message__arrived__params.html#aba131b39d189b2c052444c10b982a9bf" title="Returns reference to the arrived message.">in_message</a>());</div>
<div class="line">  out_str(inm.headers_str());</div>
<div class="line">  <span class="comment">//inm.data();</span></div>
<div class="line"></div>
<div class="line">  params.<a class="code" href="classunicomm_1_1params__base.html#af45141bb3d78dc963d19a6c8151ac716" title="Returns an object responsible for communication.">comm</a>().<a class="code" href="classunicomm_1_1communicator.html#af935e7144a562f8a58269d5f823a803b" title="Brakes the connection.">disconnect</a>();</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<h2><a class="anchor" id="http_server_session_subsection"></a>
Server</h2>
<p>The server's session provides http server side logic implementation.</p>
 <div class="fragment"><div class="line"><span class="keyword">class </span>server_session : <span class="keyword">public</span> session_base&lt;server_session, server_session_params&gt;</div>
<div class="line">{</div>
<div class="line"><span class="comment">// interface</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">typedef</span> uni_http::session_base&lt;server_session, server_session_params&gt; base_type;</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// don&#39;t need connected parameters here in this sample</span></div>
<div class="line">  server_session(<span class="keyword">const</span> <a class="code" href="classunicomm_1_1connected__params.html" title="Connected handler parameters.">unicomm::connected_params</a>&amp; <span class="comment">/*params*/</span>, </div>
<div class="line">                 <span class="keyword">const</span> session_params_type&amp; session_params):</div>
<div class="line">    base_type(session_params),</div>
<div class="line">    _served_hosts(session_params.served_hosts()),</div>
<div class="line">    _timeout(boost::posix_time::seconds(30)),</div>
<div class="line">    _track_tout(false)</div>
<div class="line">  {</div>
<div class="line">    add_connected_handler(session_params.connected_handler());</div>
<div class="line">    add_disconnected_handler(session_params.disconnected_handler());</div>
<div class="line">    set_message_sent_handler(boost::bind(&amp;server_session::message_sent_handler_1, <span class="keyword">this</span>, _1));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// instead of using connected handler start track timeout here</span></div>
<div class="line">    track_timeout();</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"><span class="comment">// private stuff</span></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">struct </span>check_resource_result</div>
<div class="line">  {</div>
<div class="line">  <span class="comment">// interface</span></div>
<div class="line">  check_resource_result(hosts_collection_type::const_iterator host_cit,</div>
<div class="line">    boost::filesystem::path target, <span class="keywordtype">bool</span> is_dir):</div>
<div class="line">    _host_cit(host_cit),</div>
<div class="line">    _target(target),</div>
<div class="line">    _is_dir(is_dir)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// empty</span></div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  hosts_collection_type::const_iterator requested_host(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _host_cit; }</div>
<div class="line">  <span class="keyword">const</span> boost::filesystem::path&amp; requested_target(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _target; }</div>
<div class="line">  <span class="keywordtype">bool</span> is_directory(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _is_dir; }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// private stuff</span></div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    hosts_collection_type::const_iterator _host_cit;</div>
<div class="line">    boost::filesystem::path _target;</div>
<div class="line">    <span class="keywordtype">bool</span> _is_dir;</div>
<div class="line">  };</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="comment">// http server site protocol implementation</span></div>
<div class="line">  response::pointer_type handle_get(<span class="keyword">const</span> uni_http::request&amp; inm);</div>
<div class="line">  response::pointer_type handle_get_file(<span class="keyword">const</span> check_resource_result&amp; r);</div>
<div class="line">  response::pointer_type handle_get_dir(<span class="keyword">const</span> check_resource_result&amp; r, <span class="keyword">const</span> std::string&amp; uri);</div>
<div class="line">  response::pointer_type handle_head(<span class="keyword">const</span> uni_http::request&amp; inm);</div>
<div class="line">  response::pointer_type handle_default(<span class="keywordtype">void</span>); <span class="comment">// default handler</span></div>
<div class="line">  <span class="comment">//message_pointer_type handle_post(const uni_http::request&amp; inm);</span></div>
<div class="line">  response::pointer_type process_request(<span class="keyword">const</span> uni_http::request&amp; inm);</div>
<div class="line">  check_resource_result check_resource(<span class="keyword">const</span> uni_http::request&amp; inm);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// incoming connection idle timeout</span></div>
<div class="line">  <span class="keywordtype">void</span> is_track_timeout(<span class="keywordtype">bool</span> v) { _track_tout = v; }</div>
<div class="line">  <span class="keywordtype">bool</span> is_track_timeout(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _track_tout; }</div>
<div class="line">  <span class="keywordtype">bool</span> is_timeout_elapsed(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _timeout.elapsed(); }</div>
<div class="line">  <span class="keywordtype">void</span> track_timeout(<span class="keywordtype">void</span>) { is_track_timeout(<span class="keyword">true</span>); smart::reset(_timeout); }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="comment">// assigned handlers</span></div>
<div class="line">  <span class="keywordtype">void</span> message_sent_handler_1(<span class="keyword">const</span> <a class="code" href="classunicomm_1_1message__sent__params.html" title="Message sent handler parameters.">unicomm::message_sent_params</a>&amp; params);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// virtual functions</span></div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> message_arrived_handler(<a class="code" href="classunicomm_1_1message__arrived__params.html" title="Message arrived handler parameters class.">unicomm::message_arrived_params</a>&amp; params);</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> error_handler(<span class="keyword">const</span> <a class="code" href="classunicomm_1_1error__params.html" title="Error handler parameters.">unicomm::error_params</a>&amp; params);</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> after_processed_handler(<span class="keyword">const</span> <a class="code" href="classunicomm_1_1params__base.html" title="Parameters base.">unicomm::after_processed_params</a>&amp; params);</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  hosts_collection_type _served_hosts;</div>
<div class="line">  smart::timeout _timeout;</div>
<div class="line">  <span class="keywordtype">bool</span> _track_tout;</div>
<div class="line">};</div>
</div><!-- fragment --></p>
<p>Below is the implementation of the server's session. Http specific stuff is ommited for sake of brevity.</p>
 <div class="fragment"><div class="line"><span class="keywordtype">void</span> uni_http::server_session::message_sent_handler_1(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classunicomm_1_1message__sent__params.html" title="Message sent handler parameters.">unicomm::message_sent_params</a>&amp; params)</div>
<div class="line">{</div>
<div class="line">  params.<a class="code" href="classunicomm_1_1params__base.html#af45141bb3d78dc963d19a6c8151ac716" title="Returns an object responsible for communication.">comm</a>().<a class="code" href="classunicomm_1_1communicator.html#af935e7144a562f8a58269d5f823a803b" title="Brakes the connection.">disconnect</a>();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// virtual functions</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> uni_http::server_session::message_arrived_handler(</div>
<div class="line">  <a class="code" href="classunicomm_1_1message__arrived__params.html" title="Message arrived handler parameters class.">unicomm::message_arrived_params</a>&amp; params)</div>
<div class="line">{</div>
<div class="line">  is_track_timeout(<span class="keyword">false</span>);</div>
<div class="line"></div>
<div class="line">  <span class="keyword">const</span> request&amp; inm = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>request&amp;<span class="keyword">&gt;</span>(params.<a class="code" href="classunicomm_1_1message__arrived__params.html#aba131b39d189b2c052444c10b982a9bf" title="Returns reference to the arrived message.">in_message</a>());</div>
<div class="line">  <span class="keyword">const</span> response::pointer_type outm = process_request(inm);</div>
<div class="line">  params.<a class="code" href="classunicomm_1_1message__arrived__params.html#a6a7075b936eba262eccd564d8cdbdfa9" title="Returns pointer to outgoing reply.">out_message</a>(outm);</div>
<div class="line"></div>
<div class="line">  stringstream ss;</div>
<div class="line"></div>
<div class="line">  ss &lt;&lt; name() &lt;&lt; <span class="stringliteral">&quot;: [&quot;</span> &lt;&lt; params.<a class="code" href="classunicomm_1_1params__base.html#af45141bb3d78dc963d19a6c8151ac716" title="Returns an object responsible for communication.">comm</a>().<a class="code" href="classunicomm_1_1communicator.html#a3e9aecebccde08dd624835ee458b46f7" title="Returns current object identifier.">id</a>() &lt;&lt; <span class="stringliteral">&quot;]: &lt;&lt; &quot;</span> </div>
<div class="line">    &lt;&lt; inm.name() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; inm.get_header(uni_http::header::host())</div>
<div class="line">    &lt;&lt; inm.uri() &lt;&lt; <span class="stringliteral">&quot; &gt;&gt; &quot;</span> &lt;&lt; outm-&gt;status_code();</div>
<div class="line"></div>
<div class="line">  out_str(ss.str());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------</span></div>
<div class="line"><span class="keywordtype">void</span> uni_http::server_session::error_handler(<span class="keyword">const</span> <a class="code" href="classunicomm_1_1error__params.html" title="Error handler parameters.">unicomm::error_params</a>&amp; params)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">throw</span>;</div>
<div class="line">  } </div>
<div class="line">  <span class="keywordflow">catch</span> (<span class="keyword">const</span> bad_request_error&amp; UNICOMM_IFDEF_DEBUG(e))</div>
<div class="line">  {</div>
<div class="line">    UNICOMM_DEBUG_OUT(<span class="stringliteral">&quot;[uni_http::server_session]: 400 Bad request error [&quot;</span> </div>
<div class="line">      &lt;&lt; e.what() &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>)</div>
<div class="line"></div>
<div class="line">    params.<a class="code" href="classunicomm_1_1params__base.html#af45141bb3d78dc963d19a6c8151ac716" title="Returns an object responsible for communication.">comm</a>().<a class="code" href="classunicomm_1_1communicator.html#af5559344b753473337f0709c177ee584" title="Puts message into outgoing queue.">send</a>(*create_bad_request_reply());</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span> (<span class="keyword">const</span> length_required_error&amp; UNICOMM_IFDEF_DEBUG(e))</div>
<div class="line">  {</div>
<div class="line">    UNICOMM_DEBUG_OUT(<span class="stringliteral">&quot;[uni_http::server_session]: 411 Length required error [&quot;</span> </div>
<div class="line">      &lt;&lt; e.what() &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>)</div>
<div class="line"></div>
<div class="line">    params.<a class="code" href="classunicomm_1_1params__base.html#af45141bb3d78dc963d19a6c8151ac716" title="Returns an object responsible for communication.">comm</a>().<a class="code" href="classunicomm_1_1communicator.html#af5559344b753473337f0709c177ee584" title="Puts message into outgoing queue.">send</a>(*create_length_required_reply());</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span> (std::exception&amp; UNICOMM_IFDEF_DEBUG(e))</div>
<div class="line">  {</div>
<div class="line">    UNICOMM_DEBUG_OUT(<span class="stringliteral">&quot;[uni_http::server_session]: A std::exception [&quot;</span> </div>
<div class="line">      &lt;&lt; e.what() &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>)</div>
<div class="line"></div>
<div class="line">    <span class="comment">//BOOST_ASSERT(!&quot;An UNEXPECTED std::exception&quot;);</span></div>
<div class="line"></div>
<div class="line">    params.<a class="code" href="classunicomm_1_1params__base.html#af45141bb3d78dc963d19a6c8151ac716" title="Returns an object responsible for communication.">comm</a>().<a class="code" href="classunicomm_1_1communicator.html#af5559344b753473337f0709c177ee584" title="Puts message into outgoing queue.">send</a>(*create_internal_server_error_reply());</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">  {</div>
<div class="line">    BOOST_ASSERT(!<span class="stringliteral">&quot;An UNKNOWN UNEXPECTED exception&quot;</span>);</div>
<div class="line"></div>
<div class="line">    params.<a class="code" href="classunicomm_1_1params__base.html#af45141bb3d78dc963d19a6c8151ac716" title="Returns an object responsible for communication.">comm</a>().<a class="code" href="classunicomm_1_1communicator.html#af5559344b753473337f0709c177ee584" title="Puts message into outgoing queue.">send</a>(*create_internal_server_error_reply());</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------</span></div>
<div class="line"><span class="keywordtype">void</span> uni_http::server_session::after_processed_handler(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classunicomm_1_1params__base.html" title="Parameters base.">unicomm::after_processed_params</a>&amp; params)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (is_track_timeout() &amp;&amp; is_timeout_elapsed())</div>
<div class="line">  {</div>
<div class="line">    UNICOMM_DEBUG_OUT(<span class="stringliteral">&quot;[uni_http::server_session]: Client idle timeout occured&quot;</span>)</div>
<div class="line"></div>
<div class="line">    is_track_timeout(false);</div>
<div class="line">    params.comm().disconnect();</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------</span></div>
<div class="line">uni_http::response::pointer_type </div>
<div class="line">uni_http::server_session::handle_get(const uni_http::request&amp; inm)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> check_resource_result r = check_resource(inm);</div>
<div class="line"></div>
<div class="line">  BOOST_ASSERT(r.requested_host() != _served_hosts.end() &amp;&amp; <span class="stringliteral">&quot; - Invalid host&quot;</span>);</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> r.is_directory()? handle_get_dir(r, inm.uri()): handle_get_file(r);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------</span></div>
<div class="line">uni_http::response::pointer_type </div>
<div class="line">uni_http::server_session::handle_get_file(<span class="keyword">const</span> server_session::check_resource_result&amp; r)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> path&amp; file_path   = r.requested_target();</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">string</span> file_name  = r.requested_target().string();</div>
<div class="line"></div>
<div class="line">  ifstream file(file_name.c_str(), ifstream::binary);</div>
<div class="line">  <span class="keywordflow">if</span> (!file)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">throw</span> internal_server_error(<span class="stringliteral">&quot;Can&#39;t handle GET request, file [&quot;</span> + file_name + <span class="stringliteral">&quot;]&quot;</span>);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  buffer_type buf(static_cast&lt;buffer_type::size_type&gt;(file_size(file_path)));</div>
<div class="line">  file.read(&amp;*buf.begin(), <span class="keyword">static_cast&lt;</span>std::streamsize<span class="keyword">&gt;</span>(buf.size()));</div>
<div class="line"></div>
<div class="line">  response::pointer_type rr = create_reply(status_code::ok(), </div>
<div class="line">    <span class="keywordtype">string</span>(buf.begin(), buf.end()));</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">string</span> file_ext  = boost_path_workaround(file_path.extension());</div>
<div class="line"></div>
<div class="line">  rr-&gt;add_header(header::content_type(), mime_type::ext_to_mime(file_ext));</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> rr;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------</span></div>
<div class="line">uni_http::response::pointer_type </div>
<div class="line">uni_http::server_session::handle_get_dir(<span class="keyword">const</span> server_session::check_resource_result&amp; r, </div>
<div class="line">                                         <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; uri)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">string</span> buf           = dir_listing_html(r.requested_target(), </div>
<div class="line">    r.requested_host()-&gt;second.root_directory(), uri);</div>
<div class="line">  response::pointer_type rr  = create_reply(status_code::ok(), </div>
<div class="line">    <span class="keywordtype">string</span>(buf.begin(), buf.end()));</div>
<div class="line"></div>
<div class="line">  rr-&gt;add_header(header::content_type(), mime_type::text_html());</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> rr;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------</span></div>
<div class="line">uni_http::response::pointer_type </div>
<div class="line">uni_http::server_session::handle_head(<span class="keyword">const</span> uni_http::request&amp; inm)</div>
<div class="line">{</div>
<div class="line">  check_resource(inm);</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> create_reply(status_code::ok());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------</span></div>
<div class="line">uni_http::response::pointer_type uni_http::server_session::handle_default(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> create_not_implemented_reply();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//uni_http::message_pointer_type </span></div>
<div class="line"><span class="comment">//uni_http::server_session::handle_post(const uni_http::request&amp; inm)</span></div>
<div class="line"><span class="comment">//{</span></div>
<div class="line"><span class="comment">//  return message_pointer_type();</span></div>
<div class="line"><span class="comment">//}</span></div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------</span></div>
<div class="line">uni_http::response::pointer_type </div>
<div class="line">uni_http::server_session::process_request(<span class="keyword">const</span> uni_http::request&amp; inm)</div>
<div class="line">{</div>
<div class="line">  response::pointer_type reply;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (is_get(inm))</div>
<div class="line">    {</div>
<div class="line">      reply = handle_get(inm);</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_head(inm))</div>
<div class="line">    {</div>
<div class="line">      reply = handle_head(inm);</div>
<div class="line">    } <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">      reply = handle_default();</div>
<div class="line">    }</div>
<div class="line">  } </div>
<div class="line">  <span class="keywordflow">catch</span> (<span class="keyword">const</span> unprocessable_entity_error&amp; UNICOMM_IFDEF_DEBUG(e))</div>
<div class="line">  {</div>
<div class="line">    UNICOMM_DEBUG_OUT(<span class="stringliteral">&quot;[uni_http::server_session]: 422 Unprocessible entity error [&quot;</span> </div>
<div class="line">      &lt;&lt; e.what() &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>)</div>
<div class="line"></div>
<div class="line">    reply = create_unprocessable_entity_reply();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span> (<span class="keyword">const</span> not_found_error&amp; UNICOMM_IFDEF_DEBUG(e))</div>
<div class="line">  {</div>
<div class="line">    UNICOMM_DEBUG_OUT(<span class="stringliteral">&quot;[uni_http::server_session]: 404 Not found error [&quot;</span> </div>
<div class="line">      &lt;&lt; e.what() &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>)</div>
<div class="line"></div>
<div class="line">    reply = create_not_found_reply();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span> (<span class="keyword">const</span> internal_server_error&amp; UNICOMM_IFDEF_DEBUG(e))</div>
<div class="line">  {</div>
<div class="line">    UNICOMM_DEBUG_OUT(<span class="stringliteral">&quot;[uni_http::server_session]: 500 Internal server error [&quot;</span> </div>
<div class="line">      &lt;&lt; e.what() &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>)</div>
<div class="line"></div>
<div class="line">    reply = create_internal_server_error_reply();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; UNICOMM_IFDEF_DEBUG(e))</div>
<div class="line">  {</div>
<div class="line">    UNICOMM_DEBUG_OUT(<span class="stringliteral">&quot;[uni_http::server_session]: An UNEXPECTED std::exception [&quot;</span> </div>
<div class="line">      &lt;&lt; e.what() &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>)</div>
<div class="line"></div>
<div class="line">    BOOST_ASSERT(!<span class="stringliteral">&quot;An UNEXPECTED std::exception&quot;</span>);</div>
<div class="line"></div>
<div class="line">    reply = create_internal_server_error_reply();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">  {</div>
<div class="line">    BOOST_ASSERT(!<span class="stringliteral">&quot;An UNKNOWN exception!&quot;</span>);</div>
<div class="line"></div>
<div class="line">    reply = create_internal_server_error_reply();</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  BOOST_ASSERT(reply != 0 &amp;&amp; <span class="stringliteral">&quot; - Reply could not be null&quot;</span>);</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> reply;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//------------------------------------------------------------------------</span></div>
<div class="line">uni_http::server_session::check_resource_result </div>
<div class="line">uni_http::server_session::check_resource(<span class="keyword">const</span> uni_http::request&amp; inm)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; wanted_host = inm.get_header(uni_http::header::host());</div>
<div class="line"></div>
<div class="line">  hosts_collection_type::const_iterator cit = _served_hosts.find(wanted_host);</div>
<div class="line">  <span class="keywordflow">if</span> (cit == _served_hosts.end())</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">throw</span> unprocessable_entity_error(<span class="stringliteral">&quot;Requested host not found [&quot;</span> + </div>
<div class="line">      wanted_host + <span class="stringliteral">&quot;]&quot;</span>);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">string</span> target_name = cit-&gt;second.root_directory() + inm.uri();</div>
<div class="line">  path target_path(target_name);</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">if</span> (!exists(target_path))</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">throw</span> not_found_error(<span class="stringliteral">&quot;Requested resource not found [&quot;</span> + target_name + <span class="stringliteral">&quot;]&quot;</span>);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">bool</span> is_dir = is_directory(target_path);</div>
<div class="line">  <span class="keywordflow">if</span> (is_dir)</div>
<div class="line">  {</div>
<div class="line">    path tmp = target_path;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (exists(tmp /= <span class="keywordtype">string</span>(<span class="stringliteral">&quot;index.html&quot;</span>)))</div>
<div class="line">    {</div>
<div class="line">      target_path = tmp;</div>
<div class="line">      is_dir      = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  UNICOMM_DEBUG_OUT(<span class="stringliteral">&quot;[uni_http::server_session]: Resource requested [&quot;</span> </div>
<div class="line">    &lt;&lt; target_path.string() &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>)</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> check_resource_result(cit, target_path, is_dir);</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<h1><a class="anchor" id="http_config_section"></a>
Configuration</h1>
<p>The last step is to define configuration to make unicomm working in proper manner.</p>
 <div class="fragment"><div class="line"><span class="keyword">namespace </span></div>
<div class="line">{</div>
<div class="line"></div>
<div class="line"><a class="code" href="classunicomm_1_1config.html" title="Unicomm configuration storage class.">unicomm::config</a>&amp; common_config(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span>unicomm;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">static</span> <a class="code" href="classunicomm_1_1config.html" title="Unicomm configuration storage class.">unicomm::config</a> conf</div>
<div class="line">    (</div>
<div class="line">      <a class="code" href="classunicomm_1_1config.html" title="Unicomm configuration storage class.">unicomm::config</a>()</div>
<div class="line">        .tcp_port(uni_http::default_port())</div>
<div class="line">        .timeouts_enabled(<span class="keyword">true</span>)</div>
<div class="line">        .message_encoder(<a class="code" href="namespaceunicomm.html#aeb7343811ca329b13f868f7c3a44ed26" title="Default creator function, can be used with the factory.">uni_http::message_encoder::create</a>())</div>
<div class="line">        .message_decoder(<a class="code" href="namespaceunicomm.html#aeb7343811ca329b13f868f7c3a44ed26" title="Default creator function, can be used with the factory.">uni_http::message_decoder::create</a>())</div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> conf;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">} <span class="comment">// unnamed namespace</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="classunicomm_1_1config.html" title="Unicomm configuration storage class.">unicomm::config</a>&amp; uni_http::server_config(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span>unicomm;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">static</span> <a class="code" href="classunicomm_1_1config.html" title="Unicomm configuration storage class.">unicomm::config</a> conf</div>
<div class="line">    (</div>
<div class="line">      common_config()</div>
<div class="line">        .dispatcher_idle_tout(10)</div>
<div class="line">        .message_factory</div>
<div class="line">          (</div>
<div class="line">            <a class="code" href="classunicomm_1_1message__base.html#a5ca7d33017875646b37b45b904d53c08" title="Messages factory type.">message_base::factory_type</a>(&amp;unicomm::create&lt;uni_http::request&gt;)</div>
<div class="line">          )</div>
<div class="line"></div>
<div class="line">#ifdef UNICOMM_SSL</div>
<div class="line"></div>
<div class="line">        .ssl_server_key_password(<span class="stringliteral">&quot;test&quot;</span>)</div>
<div class="line">        .ssl_server_cert_chain_fn(<span class="stringliteral">&quot;../../../../http/ssl/server.pem&quot;</span>)</div>
<div class="line">        .ssl_server_key_fn(<span class="stringliteral">&quot;../../../../http/ssl/server.pem&quot;</span>)</div>
<div class="line">        .ssl_server_dh_fn(<span class="stringliteral">&quot;../../../../http/ssl/dh512.pem&quot;</span>)</div>
<div class="line"></div>
<div class="line">#endif <span class="comment">// UNICOMM_SSL</span></div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> conf;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// client definition</span></div>
<div class="line"></div>
<div class="line"><a class="code" href="classunicomm_1_1config.html" title="Unicomm configuration storage class.">unicomm::config</a>&amp; uni_http::client_config(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span>unicomm;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">static</span> <a class="code" href="classunicomm_1_1config.html" title="Unicomm configuration storage class.">unicomm::config</a> conf</div>
<div class="line">    (</div>
<div class="line">      common_config()</div>
<div class="line">        .<a class="code" href="structunicomm_1_1message__info.html" title="Message meta information.">message_info</a>(<a class="code" href="structunicomm_1_1message__info.html" title="Message meta information.">message_info</a>(uni_http::request::get(), <span class="keyword">true</span>, 10000))</div>
<div class="line">        .message_factory</div>
<div class="line">          (</div>
<div class="line">            <a class="code" href="classunicomm_1_1message__base.html#a5ca7d33017875646b37b45b904d53c08" title="Messages factory type.">message_base::factory_type</a>(&amp;unicomm::create&lt;uni_http::response&gt;)</div>
<div class="line">          )</div>
<div class="line"></div>
<div class="line">#ifdef UNICOMM_SSL</div>
<div class="line"></div>
<div class="line">        .ssl_client_verity_fn(<span class="stringliteral">&quot;../../../../http/ssl/ca.pem&quot;</span>)</div>
<div class="line"></div>
<div class="line">#endif <span class="comment">// UNICOMM_SSL</span></div>
<div class="line">    );</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> conf;</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<h1><a class="anchor" id="http_decoder_section"></a>
Decoder</h1>
<p><a class="el" href="classunicomm_1_1message__decoder__base.html#a3740aeb66c855a18931b29dfa52a1395" title="Algorithm implementation.">unicomm::message_decoder_base::perform_decode()</a> provides "template method" implementation. If required logic fits to this template you should override serveral virtual function as shown below. Instead override entire <a class="el" href="classunicomm_1_1message__decoder__base.html#a3740aeb66c855a18931b29dfa52a1395" title="Algorithm implementation.">unicomm::message_decoder_base::perform_decode()</a> and implement the logic you need.</p>
 <div class="fragment"><div class="line"><span class="keyword">class </span>message_decoder : <span class="keyword">public</span> <a class="code" href="classunicomm_1_1message__decoder__base.html" title="Unicomm message decoder base class.">unicomm::message_decoder_base</a></div>
<div class="line">{</div>
<div class="line"><span class="comment">// interface</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">static</span> <a class="code" href="classunicomm_1_1message__decoder__base.html#aa72aee4b740d602228e27a3c34536559" title="Message decoder base smart pointer type.">unicomm::message_decoder_base::pointer_type</a> <a class="code" href="namespaceunicomm.html#aeb7343811ca329b13f868f7c3a44ed26" title="Default creator function, can be used with the factory.">create</a>(<span class="keywordtype">void</span>) </div>
<div class="line">  { </div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="classunicomm_1_1message__decoder__base.html#aa72aee4b740d602228e27a3c34536559" title="Message decoder base smart pointer type.">unicomm::message_decoder_base::pointer_type</a>(<span class="keyword">new</span> message_decoder());</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  message_decoder(<span class="keywordtype">void</span>): _length(0), _last_buf_size(0) { <span class="comment">/* emtpy */</span> }</div>
<div class="line"></div>
<div class="line"><span class="comment">// private stuff</span></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">virtual</span> iter_pair_type find_raw_message(<a class="code" href="classunicomm_1_1comm__buffer.html#a10debf43ea8aef87d56b411fdda0e87b" title="Actual buffer type that provides specific operations.">unicomm::comm_buffer::buffer_type</a>&amp; buffer, </div>
<div class="line">    <a class="code" href="classunicomm_1_1session__base.html" title="Session interface which should be implemented by user&#39;s code to receive event notifications.">unicomm::session_base</a>&amp; session);</div>
<div class="line">  <span class="keyword">virtual</span> std::string&amp; decode_raw_message(std::string&amp; raw_message, </div>
<div class="line">    <a class="code" href="classunicomm_1_1session__base.html" title="Session interface which should be implemented by user&#39;s code to receive event notifications.">unicomm::session_base</a>&amp; session);</div>
<div class="line">  <span class="keyword">virtual</span> std::string get_message_name(<span class="keyword">const</span> std::string&amp; raw_message, </div>
<div class="line">    <a class="code" href="classunicomm_1_1session__base.html" title="Session interface which should be implemented by user&#39;s code to receive event notifications.">unicomm::session_base</a>&amp; session);</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  iter_pair_type finish_decode(<a class="code" href="namespaceunicomm.html#aa3ede3a0f1f6521050286f85efee560f" title="Incoming buffer type.">unicomm::in_buffer_type</a>&amp; buffer);</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">size_t</span> _length;</div>
<div class="line">  <span class="keywordtype">size_t</span> _last_buf_size;</div>
<div class="line">};</div>
</div><!-- fragment --></p>
 <div class="fragment"><div class="line"><a class="code" href="classunicomm_1_1message__decoder__base.html#af096e64c9e1f8ae2b97de7329d53904e" title="Pair of income buffer iterators.">unicomm::message_decoder_base::iter_pair_type</a> </div>
<div class="line">uni_http::message_decoder::find_raw_message(<a class="code" href="classunicomm_1_1comm__buffer.html#a10debf43ea8aef87d56b411fdda0e87b" title="Actual buffer type that provides specific operations.">unicomm::comm_buffer::buffer_type</a>&amp; buffer, </div>
<div class="line">                                            <a class="code" href="classunicomm_1_1session__base.html" title="Session interface which should be implemented by user&#39;s code to receive event notifications.">unicomm::session_base</a>&amp; session)</div>
<div class="line">{</div>
<div class="line">  message_decoder_base::iter_pair_type bounds = make_pair(buffer.end(), buffer.end());</div>
<div class="line"></div>
<div class="line">  <span class="comment">// if size is not changed assume there were no changes, so, nothing to do</span></div>
<div class="line">  <span class="keywordflow">if</span> (_last_buf_size != buffer.size())</div>
<div class="line">  {</div>
<div class="line">    UNICOMM_DEBUG_OUT(<span class="stringliteral">&quot;[uni_http::message_decoder]: DECODE ENTER; Length = &quot;</span> </div>
<div class="line">      &lt;&lt; _length &lt;&lt; <span class="stringliteral">&quot;; Buffer size = &quot;</span> &lt;&lt; buffer.size())</div>
<div class="line"></div>
<div class="line">    _last_buf_size = buffer.size();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (_length == 0) <span class="comment">// means header is not parsed yet</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">size_t</span> i = buffer.find(head_body_separator());</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">if</span> (i != string::npos) </div>
<div class="line">      {</div>
<div class="line">        header::header_collection_type headers = parse_header(buffer.substr(0, i));</div>
<div class="line"></div>
<div class="line">        <span class="comment">// get the content length </span></div>
<div class="line">        header::header_collection_type::const_iterator cit = headers.find(header::content_length());</div>
<div class="line">        <span class="comment">//_length = (cit != headers.end()? lexical_cast&lt;size_t&gt;(cit-&gt;second): 0);</span></div>
<div class="line">        <span class="keywordflow">if</span> (cit != headers.end())</div>
<div class="line">        {</div>
<div class="line">          <span class="keywordflow">if</span> ((_length = lexical_cast&lt;size_t&gt;(cit-&gt;second)) == 0)</div>
<div class="line">          {</div>
<div class="line">            <span class="comment">// means message completed, unicomm will buffer.erase(bounds.first, bounds.second)</span></div>
<div class="line">            _length = i + head_body_separator().size(); <span class="comment">// add header size</span></div>
<div class="line">            bounds  = finish_decode(buffer);</div>
<div class="line">          } <span class="keywordflow">else</span></div>
<div class="line">          {</div>
<div class="line">            _length += i + head_body_separator().size(); <span class="comment">// add header size</span></div>
<div class="line"></div>
<div class="line">            <span class="comment">// whether message completed?</span></div>
<div class="line">            <span class="keywordflow">if</span> (_length &lt;= buffer.size())</div>
<div class="line">            {</div>
<div class="line">              bounds = finish_decode(buffer);</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">        } <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">          <span class="comment">// means undefined length</span></div>
<div class="line">          UNICOMM_DEBUG_OUT(<span class="stringliteral">&quot;[uni_http::message_decoder]: DECODE; Content-Length header is absent&quot;</span>)</div>
<div class="line"></div>
<div class="line">          <span class="comment">// Usually, message processing is identical on both client and server sites. But</span></div>
<div class="line">          <span class="comment">// sometimes it&#39;s necessary to distinct one from another. There are several</span></div>
<div class="line">          <span class="comment">// way to achieve this. You may put information into the session object and use it,</span></div>
<div class="line">          <span class="comment">// as done here. Also you may define two different classes derived from </span></div>
<div class="line">          <span class="comment">// unicomm::message_decoder_base (i.e. server_decoder &amp; client_decoder) and</span></div>
<div class="line">          <span class="comment">// implement necessary interface the way you intend.</span></div>
<div class="line">          <span class="comment">// Then you create two different configuration objects for server and client </span></div>
<div class="line">          <span class="comment">// respectively and pass corresponding decoder objects to those configurations.</span></div>
<div class="line"></div>
<div class="line">          if (session.is_server())</div>
<div class="line">          { </div>
<div class="line">            <span class="keywordflow">if</span> (i + head_body_separator().size() == buffer.size())</div>
<div class="line">            {</div>
<div class="line">              <span class="comment">// it seems there is no body contained by the request</span></div>
<div class="line">              _length = buffer.size();</div>
<div class="line">              bounds  = finish_decode(buffer);</div>
<div class="line">            } <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">              BOOST_ASSERT(buffer.size() &gt; i + head_body_separator().size());</div>
<div class="line"></div>
<div class="line">              <span class="keywordflow">throw</span> length_required_error(header::content_length() + </div>
<div class="line">                <span class="stringliteral">&quot; header not found, but required&quot;</span>);</div>
<div class="line">            }</div>
<div class="line">          } <span class="keywordflow">else</span></div>
<div class="line">          {</div>
<div class="line">            <span class="comment">// client waits for the reply within timeout and disconnects if timeout occurs</span></div>
<div class="line">            _length = numeric_limits&lt;size_t&gt;::max();</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      } </div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (_length &lt;= buffer.size())</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// whether message completed?</span></div>
<div class="line">      bounds = finish_decode(buffer);</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    UNICOMM_DEBUG_OUT(<span class="stringliteral">&quot;[uni_http::message_decoder]: DECODE EXIT; Length = &quot;</span> </div>
<div class="line">      &lt;&lt; _length &lt;&lt; <span class="stringliteral">&quot;; Buffer size = &quot;</span> &lt;&lt; buffer.size())</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> bounds;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//-----------------------------------------------------------------------------</span></div>
<div class="line"><span class="keywordtype">string</span>&amp; uni_http::message_decoder::decode_raw_message(<span class="keywordtype">string</span>&amp; raw_message, </div>
<div class="line">                                                      <a class="code" href="classunicomm_1_1session__base.html" title="Session interface which should be implemented by user&#39;s code to receive event notifications.">unicomm::session_base</a>&amp; <span class="comment">/*session*/</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> raw_message;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//-----------------------------------------------------------------------------</span></div>
<div class="line"><span class="keywordtype">string</span> uni_http::message_decoder::get_message_name(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; <span class="comment">/*raw_message*/</span>, </div>
<div class="line">                                                   <a class="code" href="classunicomm_1_1session__base.html" title="Session interface which should be implemented by user&#39;s code to receive event notifications.">unicomm::session_base</a>&amp; <span class="comment">/*session*/</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">//-----------------------------------------------------------------------------</span></div>
<div class="line"><a class="code" href="classunicomm_1_1message__decoder__base.html#af096e64c9e1f8ae2b97de7329d53904e" title="Pair of income buffer iterators.">unicomm::message_decoder_base::iter_pair_type</a> </div>
<div class="line">uni_http::message_decoder::finish_decode(<a class="code" href="namespaceunicomm.html#aa3ede3a0f1f6521050286f85efee560f" title="Incoming buffer type.">unicomm::in_buffer_type</a>&amp; buffer)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> tmp          = _length;</div>
<div class="line">  _length = _last_buf_size  = 0;</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> make_pair(buffer.begin(), buffer.begin() + tmp);</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<h1><a class="anchor" id="http_encoder_section"></a>
Encoder</h1>
<p>The encoder in opposite to decoder is quite simple.</p>
 <div class="fragment"><div class="line"><span class="keyword">class </span>message_encoder : <span class="keyword">public</span> <a class="code" href="classunicomm_1_1message__encoder__base.html" title="Unicomm message encoder class.">unicomm::message_encoder_base</a></div>
<div class="line">{</div>
<div class="line"><span class="comment">// interface</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">static</span> <a class="code" href="classunicomm_1_1message__encoder__base.html#afdcdfc452f807a4728adf3b29ec9d9dc" title="Message encoder base smart pointer type.">unicomm::message_encoder_base::pointer_type</a> <a class="code" href="namespaceunicomm.html#aeb7343811ca329b13f868f7c3a44ed26" title="Default creator function, can be used with the factory.">create</a>(<span class="keywordtype">void</span>) </div>
<div class="line">  { </div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="classunicomm_1_1message__encoder__base.html#afdcdfc452f807a4728adf3b29ec9d9dc" title="Message encoder base smart pointer type.">unicomm::message_encoder_base::pointer_type</a>(<span class="keyword">new</span> message_encoder());</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"><span class="comment">// private stuff</span></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <a class="code" href="namespaceunicomm.html#aa873a5862a912494d96807f943ac99f0" title="Outgoing buffer type.">unicomm::out_buffer_type</a>&amp; encode_raw_message(<a class="code" href="namespaceunicomm.html#aa873a5862a912494d96807f943ac99f0" title="Outgoing buffer type.">unicomm::out_buffer_type</a>&amp; buffer, </div>
<div class="line">    <a class="code" href="classunicomm_1_1session__base.html" title="Session interface which should be implemented by user&#39;s code to receive event notifications.">unicomm::session_base</a>&amp; session);</div>
<div class="line">};</div>
</div><!-- fragment --></p>
 <div class="fragment"><div class="line"><a class="code" href="namespaceunicomm.html#aa873a5862a912494d96807f943ac99f0" title="Outgoing buffer type.">unicomm::out_buffer_type</a>&amp; </div>
<div class="line">uni_http::message_encoder::encode_raw_message(<a class="code" href="namespaceunicomm.html#aa873a5862a912494d96807f943ac99f0" title="Outgoing buffer type.">unicomm::out_buffer_type</a>&amp; buffer, </div>
<div class="line">                                              <a class="code" href="classunicomm_1_1session__base.html" title="Session interface which should be implemented by user&#39;s code to receive event notifications.">unicomm::session_base</a>&amp; <span class="comment">/*session*/</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> buffer;</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<h1><a class="anchor" id="http_main_section"></a>
Main</h1>
<p>Let's use the above defined stuff.</p>
 <div class="fragment"><div class="line"><span class="preprocessor">#if defined (UNI_WIN)</span></div>
<div class="line"><span class="keywordtype">int</span> _tmain(<span class="keywordtype">int</span> argc, _TCHAR* argv[])</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line"><span class="preprocessor">#endif // UNI_WIN</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    po::variables_map vm = handle_command_line(argc, argv);</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">size_t</span> threads = vm[<span class="stringliteral">&quot;threads&quot;</span>].as&lt;<span class="keywordtype">size_t</span>&gt;();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (threads &lt; 1) { threads = 1; }</div>
<div class="line">    <span class="keywordflow">if</span> (threads &gt; 10) { threads = 10; }</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (vm.count(<span class="stringliteral">&quot;url&quot;</span>) == 0)</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; host = vm[<span class="stringliteral">&quot;host&quot;</span>].as&lt;<span class="keywordtype">string</span>&gt;();</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; port = vm[<span class="stringliteral">&quot;port&quot;</span>].as&lt;<span class="keywordtype">string</span>&gt;();</div>
<div class="line"></div>
<div class="line">      <span class="comment">//fixme: setter for configuration in dispatcher?</span></div>
<div class="line">      <span class="keyword">const</span> boost::asio::ip::tcp::resolver::query q(host, port);</div>
<div class="line">      <a class="code" href="classunicomm_1_1host__resolver.html" title="Host resolving helper.">unicomm::host_resolver</a> resolver = <a class="code" href="namespaceunicomm.html#a22eef6ac4a259c921fe603ebde6a0907" title="Resolves specified host name or address.">unicomm::resolve_host</a>(q);</div>
<div class="line"></div>
<div class="line">      uni_http::server_config().endpoint(*resolver.<a class="code" href="classunicomm_1_1host__resolver.html#a7bce861a7de105f53b2fd2382fb240d4" title="Returns iterator to the first resolved endpoint.">begin</a>());</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef UNI_UNIX</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">      <span class="keywordflow">if</span> (vm.count(<span class="stringliteral">&quot;daemon&quot;</span>) != 0)</div>
<div class="line">      {</div>
<div class="line">        <span class="keyword">const</span> daemonize_result_type res = become_daemon();</div>
<div class="line">        <span class="keywordflow">if</span> (!is_daemonize_error(res))</div>
<div class="line">        {</div>
<div class="line">          <span class="keywordflow">if</span> (is_parent_process(res))</div>
<div class="line">          {</div>
<div class="line">            cout &lt;&lt; <span class="stringliteral">&quot;\r\n[http]: Daemon successfully started; pid = &quot;</span> &lt;&lt; res.second</div>
<div class="line">              &lt;&lt; <span class="stringliteral">&quot;\r\n[http]: To terminate process use &#39;sudo kill -s SIGTERM &quot;</span></div>
<div class="line">              &lt;&lt; res.second &lt;&lt; <span class="stringliteral">&quot;&#39;\r\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">            UNICOMM_DEBUG_OUT(<span class="stringliteral">&quot;[http]: Parent: exit&quot;</span>)</div>
<div class="line">            exit(EXIT_SUCCESS);</div>
<div class="line">          }</div>
<div class="line"></div>
<div class="line">          UNICOMM_DEBUG_OUT(&quot;[http]: Child: demon now; pid = &quot; &lt;&lt; res.second)</div>
<div class="line">          UNICOMM_DEBUG_OUT(&quot;[http]: Child: starting forever loop...&quot;)</div>
<div class="line">          <span class="comment">// start server in child process</span></div>
<div class="line">          start(server(), threads);</div>
<div class="line">          <span class="comment">// forever loop</span></div>
<div class="line">          while (true) { sleep(seconds(1)); }</div>
<div class="line">        } <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">          cout &lt;&lt; <span class="stringliteral">&quot;\r\n[http]: An error occurred while trying to become a demon... exit&quot;</span> &lt;&lt; endl;</div>
<div class="line">          UNICOMM_DEBUG_OUT(<span class="stringliteral">&quot;[http]: An error occurred while trying to become a demon... exit&quot;</span>)</div>
<div class="line">          exit(EXIT_FAILURE);</div>
<div class="line">        }</div>
<div class="line">      } else</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#endif // UNI_UNIX</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">      {</div>
<div class="line">        start(server(), threads);</div>
<div class="line"></div>
<div class="line">        uni_http::out_str(<span class="stringliteral">&quot;Press a key to quit&quot;</span>);</div>
<div class="line">        _getch();</div>
<div class="line"></div>
<div class="line">        stop(server());</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; url  = vm[<span class="stringliteral">&quot;url&quot;</span>].as&lt;<span class="keywordtype">string</span>&gt;();</div>
<div class="line"></div>
<div class="line">      client_send_request(client(), url);</div>
<div class="line"></div>
<div class="line">      <span class="keywordflow">do</span></div>
<div class="line">      {</div>
<div class="line">        sleep(millisec(200));</div>
<div class="line">      } <span class="keywordflow">while</span> (client().connections_count());</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e)</div>
<div class="line">  {</div>
<div class="line">    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;An error occurred: &quot;</span> &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">  {</div>
<div class="line">    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;An error occurred: Unknown error&quot;</span> &lt;&lt; endl;</div>
<div class="line"></div>
<div class="line">    BOOST_ASSERT(!<span class="stringliteral">&quot;Unknown error&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<h1>Sources</h1>
<p><a class="el" href="http_sources_page.html">Source code</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Jun 1 2013 01:38:54 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.2 </li>
  </ul>
</div>
</body>
</html>
