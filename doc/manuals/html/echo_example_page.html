<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Echo</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('echo_example_page.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Echo </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This example shows how to use unicomm optional facilities like predefined binary message format, timeouts and etc. to implement communication. The request is answered with reply bears the copy of request's data. </p>
<h1><a class="anchor" id="echo_includes_section"></a>
Includes</h1>
<p>We include unicomm core and binary message.</p>
 <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="bin__message_8hpp.html" title="Binary message definition.">unicomm/facade/bin_message.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="unicomm_8hpp.html" title="Unicomm optional interface header for convinience.">unicomm/unicomm.hpp</a>&gt;</span></div>
</div><!-- fragment --></p>
<h1><a class="anchor" id="echo_messages_section"></a>
Messages</h1>
<p>Define message class template. Each message class must define name() function returns the message type unique identifier.</p>
<p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">char</span> Name&gt;</div>
<div class="line"><span class="keyword">struct </span>basic_message : <span class="keyword">public</span> <a class="code" href="classunicomm_1_1bin__message.html" title="Message which is serialized into binary array.">unicomm::bin_message</a></div>
<div class="line">{</div>
<div class="line"><span class="comment">// interface</span></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// this is only made for convenience</span></div>
<div class="line">  <span class="comment">// strange initialization due to string constructor assumes</span></div>
<div class="line">  <span class="comment">// that &#39;\0&#39; is null-terminator.</span></div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> std::string&amp; static_name(<span class="keywordtype">void</span>)</div>
<div class="line">    { <span class="keyword">static</span> <span class="keyword">const</span> std::string s = std::string() += Name; <span class="keywordflow">return</span> s; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">const</span> std::string&amp; <a class="code" href="classunicomm_1_1message__base.html#aa46bc8b0d0c9e9a28e8b7e6d5cf5b4ed" title="Returns message name.">name</a>(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> static_name(); }</div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="keyword">explicit</span> basic_message(<span class="keyword">const</span> std::string&amp; s = <span class="stringliteral">&quot;&quot;</span>): _data(s) { <span class="comment">/*empty*/</span> }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">const</span> std::string&amp; data(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _data; }</div>
<div class="line">  <span class="keywordtype">void</span> data(<span class="keyword">const</span> std::string&amp; s) { _data = s; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  std::string <a class="code" href="classunicomm_1_1bin__message.html#a2690897698d307ba1bed599468e9a413" title="Serializes message to a std::string.">serialize</a>(<span class="keywordtype">void</span>)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">  </span>{</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="classunicomm_1_1bin__message.html#a2690897698d307ba1bed599468e9a413" title="Serializes message to a std::string.">unicomm::bin_message::serialize</a>().append(_data);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">void</span> unserialize_tail(<span class="keyword">const</span> std::string &amp;tail)</div>
<div class="line">  {</div>
<div class="line">    _data = tail;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  std::string _data;</div>
<div class="line">};</div>
</div><!-- fragment --></p>
<p>Define request</p>
<p><div class="fragment"><div class="line"><span class="keyword">typedef</span> basic_message&lt;&#39;1&#39;&gt; echo_request_message;</div>
</div><!-- fragment --></p>
<p>and reply.</p>
<p><div class="fragment"><div class="line"><span class="keyword">typedef</span> basic_message&lt;&#39;2&#39;&gt; echo_reply_message;</div>
</div><!-- fragment --></p>
<dl class="section note"><dt>Note</dt><dd>To safely (platform independent) serialize integral types use <a class="el" href="namespaceunicomm.html#ae46c042991113654275f864bc2392a61" title="Serializes given integer type into binary collection.">unicomm::int_to_vec()</a> and <a class="el" href="namespaceunicomm.html#ae1f1962f58c339b3f67495f3a8840f85" title="Unserialize given integer type from a raw data sequence.">unicomm::int_from_vec()</a>. The floating point serializators are not provided.</dd></dl>
<h1><a class="anchor" id="echo_session_params_section"></a>
Session parameters</h1>
<p>We are going to pass parameters to the client's session.</p>
<p><div class="fragment"><div class="line"><span class="comment">// client session parameters</span></div>
<div class="line"><span class="keyword">struct </span>client_session_params</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">explicit</span> client_session_params(<span class="keyword">const</span> <a class="code" href="namespaceunicomm.html#a782df77eb94111f0c1095637af4674ec" title="Auxiliary strings type.">unicomm::strings_type</a>&amp; requests_list,</div>
<div class="line">                                 <span class="keywordtype">bool</span> is_infinite, <span class="keywordtype">size_t</span> clients_num):</div>
<div class="line">    _requests_list(requests_list),</div>
<div class="line">    _is_infinite(is_infinite),</div>
<div class="line">    _clients_num(clients_num)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// empty</span></div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="namespaceunicomm.html#a782df77eb94111f0c1095637af4674ec" title="Auxiliary strings type.">unicomm::strings_type</a>&amp; requests_list(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _requests_list; }</div>
<div class="line">  <span class="keywordtype">bool</span> is_infinite(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _is_infinite; }</div>
<div class="line">  <span class="keywordtype">size_t</span> clients_number(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _clients_num; }</div>
<div class="line"></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <a class="code" href="namespaceunicomm.html#a782df77eb94111f0c1095637af4674ec" title="Auxiliary strings type.">unicomm::strings_type</a> _requests_list;</div>
<div class="line">  <span class="keywordtype">bool</span> _is_infinite;</div>
<div class="line">  <span class="keywordtype">size_t</span> _clients_num;</div>
<div class="line">};</div>
</div><!-- fragment --></p>
<p>The server's session has no parameters. To designate the session has no specific parameters use <a class="el" href="structunicomm_1_1void__session__params.html" title="Represents session parameters absence.">unicomm::void_session_params</a> or leave the template parameter unspecified while inheriting the <a class="el" href="classunicomm_1_1basic__session.html" title="Session interface to be implemented by user&#39;s code to receive event notifications.">unicomm::basic_session</a> or <a class="el" href="classunicomm_1_1extended__session.html" title="Session class which allows to map callable objects to events.">unicomm::extended_session</a>. This makes the compiler to use specialized versions of class templates while instantiating session class template. To pass extra parameters to the session use boost::bind when setting up the <a class="el" href="echo_example_page.html#echo_config_section">configuration</a>.</p>
<p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="structunicomm_1_1void__session__params.html" title="Represents session parameters absence.">unicomm::void_session_params</a> server_session_params;</div>
</div><!-- fragment --></p>
<h1><a class="anchor" id="echo_session_section"></a>
Session</h1>
<p>We define the session that holds session specific data and implements business logic by inheriting it from <a class="el" href="classunicomm_1_1extended__session.html" title="Session class which allows to map callable objects to events.">unicomm::extended_session</a>.</p>
<p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> SessionParamsT&gt;</div>
<div class="line"><span class="keyword">class </span>session : <span class="keyword">public</span> <a class="code" href="classunicomm_1_1extended__session.html" title="Session class which allows to map callable objects to events.">unicomm::extended_session</a>&lt;session&lt;SessionParamsT&gt;, SessionParamsT&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">typedef</span> <a class="code" href="classunicomm_1_1extended__session.html" title="Session class which allows to map callable objects to events.">unicomm::extended_session&lt;session&lt;SessionParamsT&gt;</a>, SessionParamsT&gt; <a class="code" href="classunicomm_1_1basic__session.html#a409bf5d5b419461ffb7b6ce349ceccae" title="Session base type.">base_type</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// interface</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">public</span>:</div>
</div><!-- fragment --></p>
<p>Server session here doesn't have parameters and client session does. So, we define two distinct constructors for server and for client.</p>
<p><div class="fragment"><div class="line">  <span class="comment">// called on client&#39;s side</span></div>
<div class="line">  <span class="keyword">explicit</span> session(<span class="keyword">const</span> <a class="code" href="classunicomm_1_1connected__params.html" title="Connected handler parameters.">unicomm::connected_params</a>&amp; <span class="comment">/*params*/</span>,</div>
<div class="line">                   <span class="keyword">const</span> SessionParamsT&amp; extra_params):</div>
<div class="line">    base_type(extra_params),</div>
<div class="line">    _timeout(timeout)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// bind handlers</span></div>
<div class="line">    set_message_arrived_handler(echo_request_message::static_name(),</div>
<div class="line">      boost::bind(&amp;session::echo_request_arrived_handler, <span class="keyword">this</span>, _1));</div>
<div class="line"></div>
<div class="line">    set_message_arrived_handler(echo_reply_message::static_name(),</div>
<div class="line">      boost::bind(&amp;session::echo_reply_arrived_handler, <span class="keyword">this</span>, _1));</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// called on server&#39;s side</span></div>
<div class="line">  <span class="keyword">explicit</span> session(<span class="keyword">const</span> <a class="code" href="classunicomm_1_1connected__params.html" title="Connected handler parameters.">unicomm::connected_params</a>&amp; <span class="comment">/*params*/</span>):</div>
<div class="line">    _timeout(timeout)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// bind handlers</span></div>
<div class="line">    set_message_arrived_handler(echo_request_message::static_name(),</div>
<div class="line">      boost::bind(&amp;session::echo_request_arrived_handler, <span class="keyword">this</span>, _1));</div>
<div class="line"></div>
<div class="line">    set_message_arrived_handler(echo_reply_message::static_name(),</div>
<div class="line">      boost::bind(&amp;session::echo_reply_arrived_handler, <span class="keyword">this</span>, _1));</div>
<div class="line">  }</div>
</div><!-- fragment --></p>
<p>In the request handler we send reply and print the information. To set the reply to the incoming request <a class="el" href="classunicomm_1_1message__arrived__params.html#a6a7075b936eba262eccd564d8cdbdfa9" title="Returns pointer to outgoing reply.">unicomm::message_arrived_params::out_message()</a> is used. Another way to send a reply is to save the incoming message id acessible through <a class="el" href="classunicomm_1_1message__base.html#a99b0cc1920dec3cc6844003aab33fb65" title="Returns message instance identifier.">unicomm::message_base::id()</a> and use it as a reply id when sending the message. It's necessary to set <a class="el" href="classunicomm_1_1message__base.html#afbc6b6cb5b609597a326dd0d7374774b" title="Returns message instance reply id.">unicomm::message_base::rid()</a> to this value and call one of the <a class="el" href="namespaceunicomm.html#aef3322107167b41bb771a17061f9630c" title="Sends given message to the specified client.">unicomm::send_one()</a> or <a class="el" href="classunicomm_1_1dispatcher.html#afe9bca24bce4690e9a524acb4930e4e7" title="Sends a message to the remote side of the connection with the given id.">unicomm::dispatcher::send_one()</a> variant. You may also perform disconnect by calling params.comm().disconnect() or throwing <a class="el" href="classunicomm_1_1disconnected__error.html" title="Disconnected error exception.">unicomm::disconnected_error</a>.</p>
<p><div class="fragment"><div class="line">  <span class="keywordtype">void</span> echo_request_arrived_handler(<a class="code" href="classunicomm_1_1message__arrived__params.html" title="Message arrived handler parameters class.">unicomm::message_arrived_params</a>&amp; params)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> echo_request_message&amp; inm =</div>
<div class="line">      <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>echo_request_message&amp;<span class="keyword">&gt;</span>(params.<a class="code" href="classunicomm_1_1message__arrived__params.html#aba131b39d189b2c052444c10b982a9bf" title="Returns reference to the arrived message.">in_message</a>());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// to reply just fill the out_message() or use unicomm::send_one()</span></div>
<div class="line">    <span class="keyword">typedef</span> <a class="code" href="classunicomm_1_1message__base.html#accff8c5e259e645ec75a691159e4dc4a" title="Message smart pointer type.">unicomm::message_base::pointer_type</a> message_pointer_type;</div>
<div class="line">    <span class="comment">// the reply&#39;s id will be assigned params.out_message_id() returned value</span></div>
<div class="line">    params.<a class="code" href="classunicomm_1_1message__arrived__params.html#a6a7075b936eba262eccd564d8cdbdfa9" title="Returns pointer to outgoing reply.">out_message</a>(message_pointer_type(<span class="keyword">new</span> echo_reply_message(inm.data())));</div>
<div class="line"></div>
<div class="line">    std::stringstream ss;</div>
<div class="line"></div>
<div class="line">    ss &lt;&lt; name() &lt;&lt; <span class="stringliteral">&quot;&gt; [&quot;</span> &lt;&lt; params.<a class="code" href="classunicomm_1_1params__base.html#af45141bb3d78dc963d19a6c8151ac716" title="Returns an object responsible for communication.">comm</a>().<a class="code" href="classunicomm_1_1communicator.html#a3e9aecebccde08dd624835ee458b46f7" title="Returns current object identifier.">id</a>() &lt;&lt; <span class="stringliteral">&quot;]: [&quot;</span> &lt;&lt; inm.id()</div>
<div class="line">      &lt;&lt; <span class="stringliteral">&quot;]:\tREQUEST: &quot;</span> &lt;&lt; inm.data();</div>
<div class="line">    out_str(ss.str());</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// echo reply handler</span></div>
<div class="line">  <span class="keywordtype">void</span> echo_reply_arrived_handler(<a class="code" href="classunicomm_1_1message__arrived__params.html" title="Message arrived handler parameters class.">unicomm::message_arrived_params</a>&amp; params)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> echo_reply_message&amp; inm =</div>
<div class="line">      <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>echo_reply_message&amp;<span class="keyword">&gt;</span>(params.<a class="code" href="classunicomm_1_1message__arrived__params.html#aba131b39d189b2c052444c10b982a9bf" title="Returns reference to the arrived message.">in_message</a>());</div>
<div class="line"></div>
<div class="line">    std::stringstream ss;</div>
<div class="line"></div>
<div class="line">    ss &lt;&lt; name() &lt;&lt; <span class="stringliteral">&quot;&gt; [&quot;</span> &lt;&lt; params.<a class="code" href="classunicomm_1_1params__base.html#af45141bb3d78dc963d19a6c8151ac716" title="Returns an object responsible for communication.">comm</a>().<a class="code" href="classunicomm_1_1communicator.html#a3e9aecebccde08dd624835ee458b46f7" title="Returns current object identifier.">id</a>() &lt;&lt; <span class="stringliteral">&quot;]: [&quot;</span> &lt;&lt; inm.id()</div>
<div class="line">      &lt;&lt; <span class="stringliteral">&quot;]: [&quot;</span> &lt;&lt; inm.rid() &lt;&lt; <span class="stringliteral">&quot;]: \tREPLY: &quot;</span> &lt;&lt; inm.data();</div>
<div class="line">    out_str(ss.str());</div>
<div class="line">  }</div>
</div><!-- fragment --></p>
<p>In this example "same" session type is used by client and server. As you can see the behavior in certain cases (e.g. connected handler) is split by using specializations. In real world the difference between server and client can be greater. So, it is better solution to split code to different classes that represent server and client side sessions.</p>
<p><div class="fragment"><div class="line">  <span class="keywordtype">void</span> connected_handler(<span class="keyword">const</span> <a class="code" href="classunicomm_1_1connected__params.html" title="Connected handler parameters.">unicomm::connected_params</a>&amp; params)</div>
<div class="line">  {</div>
<div class="line">    std::stringstream ss;</div>
<div class="line"></div>
<div class="line">    ss &lt;&lt; name() &lt;&lt; <span class="stringliteral">&quot;&gt; [&quot;</span> &lt;&lt; params.<a class="code" href="classunicomm_1_1params__base.html#af45141bb3d78dc963d19a6c8151ac716" title="Returns an object responsible for communication.">comm</a>().<a class="code" href="classunicomm_1_1communicator.html#a3e9aecebccde08dd624835ee458b46f7" title="Returns current object identifier.">id</a>() &lt;&lt; <span class="stringliteral">&quot;]:\tCONNECTED; local endpoint: &quot;</span></div>
<div class="line">      &lt;&lt; params.<a class="code" href="classunicomm_1_1params__base.html#af45141bb3d78dc963d19a6c8151ac716" title="Returns an object responsible for communication.">comm</a>().<a class="code" href="classunicomm_1_1communicator.html#a0e6fc78c1d19433df3e4274d9443a9eb" title="Returns local endpoint of the established connection.">local_endpoint</a>() &lt;&lt; <span class="stringliteral">&quot;, remote endpoint: &quot;</span></div>
<div class="line">      &lt;&lt; params.<a class="code" href="classunicomm_1_1params__base.html#af45141bb3d78dc963d19a6c8151ac716" title="Returns an object responsible for communication.">comm</a>().<a class="code" href="classunicomm_1_1communicator.html#a9ce6711b1ff9ac445c3db3ce9267b9e9" title="Returns remote endpoint that the communicator is connected to.">remote_endpoint</a>();</div>
<div class="line">    out_str(ss.str());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// split the behavior in compile time</span></div>
<div class="line">    side_connected_handler&lt;SessionParamsT&gt;(params);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// call base (extended_session) handler if we need</span></div>
<div class="line">    <span class="comment">// assigned connected handlers to be called if there are</span></div>
<div class="line">    base_type::connected_handler(params);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ParamsT&gt;</div>
<div class="line">  <span class="keywordtype">void</span> side_connected_handler(<span class="keyword">const</span> <a class="code" href="classunicomm_1_1connected__params.html" title="Connected handler parameters.">unicomm::connected_params</a>&amp; params);</div>
<div class="line"></div>
<div class="line">  <span class="comment">//----------------------------------------------------------------------</span></div>
<div class="line">  <span class="comment">// after processed handler</span></div>
<div class="line">  <span class="keywordtype">void</span> after_processed_handler(<span class="keyword">const</span> <a class="code" href="classunicomm_1_1params__base.html" title="Parameters base.">unicomm::after_processed_params</a>&amp; params)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// called approximately within config().sleep_working_thread_tout() ms</span></div>
<div class="line">    <span class="comment">// zero means infinite timeout, if timeout is infinte only called</span></div>
<div class="line">    <span class="comment">// if there is data to be processed</span></div>
<div class="line">    <span class="comment">// default timeout is 50 ms.</span></div>
<div class="line">    side_after_processed_handler&lt;SessionParamsT&gt;(params);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ParamsT&gt;</div>
<div class="line">  <span class="keywordtype">void</span> side_after_processed_handler(<span class="keyword">const</span> <a class="code" href="classunicomm_1_1params__base.html" title="Parameters base.">unicomm::after_processed_params</a>&amp; params);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// below stuff just prints the info to the console</span></div>
<div class="line">  <span class="comment">// disconnected handler</span></div>
<div class="line">  <span class="keywordtype">void</span> disconnected_handler(<span class="keyword">const</span> <a class="code" href="classunicomm_1_1disconnected__params.html" title="Disconnected handler parameters.">unicomm::disconnected_params</a>&amp; params)</div>
<div class="line">  {</div>
<div class="line">    std::stringstream ss;</div>
<div class="line"></div>
<div class="line">    ss &lt;&lt; name() &lt;&lt; <span class="stringliteral">&quot;&gt; [&quot;</span> &lt;&lt; params.<a class="code" href="classunicomm_1_1params__base.html#af45141bb3d78dc963d19a6c8151ac716" title="Returns an object responsible for communication.">comm</a>().<a class="code" href="classunicomm_1_1communicator.html#a3e9aecebccde08dd624835ee458b46f7" title="Returns current object identifier.">id</a>() &lt;&lt; <span class="stringliteral">&quot;]:\tDISCONNECTED; &quot;</span></div>
<div class="line">      &lt;&lt; params.<a class="code" href="classunicomm_1_1disconnected__params.html#a2b7ce786a59652170db257d25d85c973" title="Returns a disconnected reason.">error_code</a>() &lt;&lt; <span class="stringliteral">&quot;; &quot;</span> &lt;&lt; params.<a class="code" href="classunicomm_1_1disconnected__params.html#a861486491dae14352b0b0d49fc23542f" title="Returns a disconnected reason string.">what</a>();</div>
<div class="line">    out_str(ss.str());</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// message timeout handler</span></div>
<div class="line">  <span class="keywordtype">void</span> message_timeout_handler(<span class="keyword">const</span> <a class="code" href="classunicomm_1_1message__sent__params.html" title="Message sent handler parameters.">unicomm::message_timeout_params</a>&amp; params)</div>
<div class="line">  {</div>
<div class="line">    std::stringstream ss;</div>
<div class="line"></div>
<div class="line">    ss &lt;&lt; name() &lt;&lt; <span class="stringliteral">&quot;&gt; [&quot;</span> &lt;&lt; params.<a class="code" href="classunicomm_1_1params__base.html#af45141bb3d78dc963d19a6c8151ac716" title="Returns an object responsible for communication.">comm</a>().<a class="code" href="classunicomm_1_1communicator.html#a3e9aecebccde08dd624835ee458b46f7" title="Returns current object identifier.">id</a>() &lt;&lt; <span class="stringliteral">&quot;]: [&quot;</span></div>
<div class="line">      &lt;&lt; params.<a class="code" href="classunicomm_1_1message__sent__params.html#a39e3d31bfff1fdd8e072b6071d284954" title="Returns a sent message&#39;s identifier.">message_id</a>() &lt;&lt; <span class="stringliteral">&quot;]:\tTIMEOUT&quot;</span>;</div>
<div class="line">    out_str(ss.str());</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// error handler</span></div>
<div class="line">  <span class="keywordtype">void</span> error_handler(<span class="keyword">const</span> <a class="code" href="classunicomm_1_1error__params.html" title="Error handler parameters.">unicomm::error_params</a>&amp; params)</div>
<div class="line">  {</div>
<div class="line">    std::stringstream ss;</div>
<div class="line"></div>
<div class="line">    ss &lt;&lt; name() &lt;&lt; <span class="stringliteral">&quot;&gt; [&quot;</span> &lt;&lt; params.<a class="code" href="classunicomm_1_1params__base.html#af45141bb3d78dc963d19a6c8151ac716" title="Returns an object responsible for communication.">comm</a>().<a class="code" href="classunicomm_1_1communicator.html#a3e9aecebccde08dd624835ee458b46f7" title="Returns current object identifier.">id</a>() &lt;&lt; <span class="stringliteral">&quot;]:\tERROR: &quot;</span></div>
<div class="line">      &lt;&lt; params.<a class="code" href="classunicomm_1_1error__params.html#a941ed1ac99cc26b5cd02055a854f352c" title="Returns an error description.">description</a>();</div>
<div class="line">    out_str(ss.str());</div>
<div class="line"></div>
<div class="line">    <span class="comment">// to obtain exception type rethrow the exception</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">//try</span></div>
<div class="line">    <span class="comment">//{</span></div>
<div class="line">    <span class="comment">//  throw;</span></div>
<div class="line">    <span class="comment">//} catch (const my_exception&amp; e)</span></div>
<div class="line">    <span class="comment">//{</span></div>
<div class="line">    <span class="comment">//  //...</span></div>
<div class="line">    <span class="comment">//}</span></div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// message is actually sent handler</span></div>
<div class="line">  <span class="keywordtype">void</span> message_sent_handler(<span class="keyword">const</span> <a class="code" href="classunicomm_1_1message__sent__params.html" title="Message sent handler parameters.">unicomm::message_sent_params</a>&amp; params)</div>
<div class="line">  {</div>
<div class="line">    std::stringstream ss;</div>
<div class="line"></div>
<div class="line">    ss &lt;&lt; name() &lt;&lt; <span class="stringliteral">&quot;&gt; [&quot;</span> &lt;&lt; params.<a class="code" href="classunicomm_1_1params__base.html#af45141bb3d78dc963d19a6c8151ac716" title="Returns an object responsible for communication.">comm</a>().<a class="code" href="classunicomm_1_1communicator.html#a3e9aecebccde08dd624835ee458b46f7" title="Returns current object identifier.">id</a>() &lt;&lt; <span class="stringliteral">&quot;]: [&quot;</span></div>
<div class="line">      &lt;&lt; params.<a class="code" href="classunicomm_1_1message__sent__params.html#a39e3d31bfff1fdd8e072b6071d284954" title="Returns a sent message&#39;s identifier.">message_id</a>() &lt;&lt; <span class="stringliteral">&quot;]:\tSENT&quot;</span>;</div>
<div class="line">    out_str(ss.str());</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"><span class="comment">// private stuff</span></div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">void</span> send_echo_request(<span class="keyword">const</span> <a class="code" href="classunicomm_1_1communicator.html" title="TCP communication service.">unicomm::communicator</a>&amp; comm, <span class="keyword">const</span> std::string&amp; data)</div>
<div class="line">  {</div>
<div class="line">    comm.<a class="code" href="classunicomm_1_1communicator.html#af5559344b753473337f0709c177ee584" title="Puts message into outgoing queue.">send</a>(echo_request_message(data));</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">//----------------------------------------------------------------------</span></div>
<div class="line">  <span class="keywordtype">void</span> send_echo_requests(<span class="keyword">const</span> <a class="code" href="classunicomm_1_1communicator.html" title="TCP communication service.">unicomm::communicator</a>&amp; comm)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="namespaceunicomm.html#a782df77eb94111f0c1095637af4674ec" title="Auxiliary strings type.">unicomm::strings_type</a>&amp; list = base_type::parameters().requests_list();</div>
<div class="line">    std::for_each(list.begin(), list.end(),</div>
<div class="line">      boost::bind(&amp;uni_echo::session&lt;SessionParamsT&gt;::send_echo_request,</div>
<div class="line">      <span class="keyword">this</span>, boost::ref(comm), _1));</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordtype">bool</span> is_time(<span class="keywordtype">void</span>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _timeout-- == 0; }</div>
<div class="line">  <span class="keywordtype">void</span> reset_timeout(<span class="keywordtype">void</span>) { _timeout = timeout; }</div>
<div class="line">  <span class="keyword">mutable</span> <span class="keyword">volatile</span> <span class="keywordtype">size_t</span> _timeout;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">size_t</span> timeout = 30; <span class="comment">// 1.5 seconds by default</span></div>
<div class="line">                                    <span class="comment">// in config::dispatcher_idle_tout() intervals</span></div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> session&lt;client_session_params&gt; client_session_type;</div>
<div class="line"></div>
<div class="line"><span class="keyword">typedef</span> session&lt;server_session_params&gt; server_session_type;</div>
<div class="line"></div>
<div class="line"><span class="comment">// client</span></div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">bool</span> client_session_type::is_server&lt;client_session_params&gt;(void) <span class="keyword">const</span> </div>
<div class="line">{ </div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">false</span>; </div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// server</span></div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">bool</span> server_session_type::is_server&lt;server_session_params&gt;(void) <span class="keyword">const</span> </div>
<div class="line">{ </div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">true</span>; </div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// client</span></div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> client_session_type::side_connected_handler&lt;client_session_params&gt;(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classunicomm_1_1connected__params.html" title="Connected handler parameters.">unicomm::connected_params</a>&amp; params)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (params.<a class="code" href="classunicomm_1_1params__base.html#af45141bb3d78dc963d19a6c8151ac716" title="Returns an object responsible for communication.">comm</a>().<a class="code" href="classunicomm_1_1communicator.html#ad37338c248960d5895db4eb35e2d0ce4" title="Returns a reference to the communicator object&#39;s owner.">owner</a>().<a class="code" href="classunicomm_1_1dispatcher.html#ab8c80d6f340807c3091a4a0fd5dd291b" title="Returns current connections count.">connections_count</a>() &lt; parameters().clients_number())</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// if we didn&#39;t reach the requested clients number start new connection</span></div>
<div class="line">    <span class="keyword">static_cast&lt;</span><a class="code" href="classunicomm_1_1client.html" title="Unicomm client.">unicomm::client</a>&amp;<span class="keyword">&gt;</span>(params.<a class="code" href="classunicomm_1_1params__base.html#af45141bb3d78dc963d19a6c8151ac716" title="Returns an object responsible for communication.">comm</a>().<a class="code" href="classunicomm_1_1communicator.html#ad37338c248960d5895db4eb35e2d0ce4" title="Returns a reference to the communicator object&#39;s owner.">owner</a>()).connect();</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  send_echo_requests(params.<a class="code" href="classunicomm_1_1params__base.html#af45141bb3d78dc963d19a6c8151ac716" title="Returns an object responsible for communication.">comm</a>());</div>
<div class="line">  reset_timeout();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// server</span></div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> server_session_type::side_connected_handler&lt;server_session_params&gt;(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classunicomm_1_1connected__params.html" title="Connected handler parameters.">unicomm::connected_params</a>&amp; <span class="comment">/*params*/</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// empty</span></div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// client</span></div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> client_session_type::side_after_processed_handler&lt;client_session_params&gt;(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classunicomm_1_1params__base.html" title="Parameters base.">unicomm::after_processed_params</a>&amp; params)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (is_time())</div>
<div class="line">  {</div>
<div class="line">    reset_timeout();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (parameters().is_infinite())</div>
<div class="line">    {</div>
<div class="line">      send_echo_requests(params.<a class="code" href="classunicomm_1_1params__base.html#af45141bb3d78dc963d19a6c8151ac716" title="Returns an object responsible for communication.">comm</a>());</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// server</span></div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> server_session_type::side_after_processed_handler&lt;server_session_params&gt;(</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classunicomm_1_1params__base.html" title="Parameters base.">unicomm::after_processed_params</a>&amp; <span class="comment">/*params*/</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// empty</span></div>
<div class="line">}</div>
</div><!-- fragment --></p>
<p>Other handlers are omitted due to they only prints information. Please, view sources <a class="el" href="echo_sources_page.html">here</a>.</p>
<h1><a class="anchor" id="echo_client_spesific_section"></a>
Client specific</h1>
<p>We also define client specific handler that fired if the connection could not be established due to some reason. It prints information and initiates new connection if the connections number is zero. The handler is passed to the client on it's constructor.</p>
 <div class="fragment"><div class="line"><span class="keywordtype">void</span> uni_echo::connect_error_handler(<span class="keyword">const</span> <a class="code" href="classunicomm_1_1connect__error__params.html" title="Connection failure parameters class.">unicomm::connect_error_params</a>&amp; params)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> tcp::endpoint&amp; remote_endpoint = params.<a class="code" href="classunicomm_1_1connect__error__params.html#aae11a8af5bae8412c2c3c538d37fe49a" title="Returns remote end point that connection was attempted.">remote_endpoint</a>();</div>
<div class="line">  <span class="keyword">const</span> boost::system::error_code&amp; err = params.<a class="code" href="classunicomm_1_1connect__error__params.html#ada655ecf0159a8f206cb32f756fe4a11" title="Returns an error code of the connection attempt.">error_code</a>();</div>
<div class="line"></div>
<div class="line">  stringstream ss;</div>
<div class="line"></div>
<div class="line">  ss &lt;&lt; <span class="stringliteral">&quot;client&gt; connect to [&quot;</span> &lt;&lt; remote_endpoint &lt;&lt; <span class="stringliteral">&quot;] failed with error [&quot;</span> </div>
<div class="line">    &lt;&lt; err &lt;&lt; <span class="stringliteral">&quot;; &quot;</span> &lt;&lt; err.message().c_str() &lt;&lt; <span class="stringliteral">&quot;]&quot;</span>;</div>
<div class="line">  out_str(ss.str());</div>
<div class="line"></div>
<div class="line">  <span class="comment">// fixme: add session parameters to be available through config</span></div>
<div class="line">  <span class="keywordflow">if</span> (params.<a class="code" href="classunicomm_1_1connect__error__params.html#acc9fe64a0a43e061dd4714c92b970ffa" title="Returns a reference to the client object produced the event.">client</a>().<a class="code" href="classunicomm_1_1dispatcher.html#ab8c80d6f340807c3091a4a0fd5dd291b" title="Returns current connections count.">connections_count</a>() == 0)</div>
<div class="line">  {</div>
<div class="line">    sleep(milliseconds(500));</div>
<div class="line">    params.<a class="code" href="classunicomm_1_1connect__error__params.html#acc9fe64a0a43e061dd4714c92b970ffa" title="Returns a reference to the client object produced the event.">client</a>().<a class="code" href="classunicomm_1_1client.html#aac5c26bb04508204d4bd41e83d7ce4ea" title="Request to connect using endpoint which is set on constructor or previous connect call...">connect</a>();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<h1><a class="anchor" id="echo_config_section"></a>
Configuration</h1>
<p>The last step is to define configuration to make unicomm working in proper manner.</p>
<p><div class="fragment"><div class="line"><a class="code" href="classunicomm_1_1config.html" title="Unicomm configuration storage class.">unicomm::config</a>&amp; uni_echo::config(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span>unicomm;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">using</span> boost::assign::list_of;</div>
<div class="line"></div>
<div class="line">  <span class="keyword">static</span> <a class="code" href="classunicomm_1_1config.html" title="Unicomm configuration storage class.">unicomm::config</a> conf</div>
<div class="line">    (</div>
<div class="line">      <a class="code" href="classunicomm_1_1config.html" title="Unicomm configuration storage class.">unicomm::config</a>()</div>
</div><!-- fragment --></p>
<p>We tell unicomm to use 55555 port, enable timeouts handling, use unique identifiers while processing messages, that enables asynchronously send requests and receive replies. If <a class="el" href="classunicomm_1_1config.html#a73eeffe1e176f8d7737d0c1585918e0d" title="Indicates whether to use unique message identifier for every message to be sent.">unicomm::config::use_unique_message_id()</a> is false the reply will be considered as a reply to the last request has been sent.</p>
<p><div class="fragment"><div class="line">        .tcp_port(55555)</div>
<div class="line">        .timeouts_enabled(<span class="keyword">true</span>)</div>
<div class="line">        .use_unique_message_id(<span class="keyword">true</span>)</div>
</div><!-- fragment --></p>
<p>The lines below provide unicomm required information about messages we have. To tell unicomm about the messages we use <a class="el" href="classunicomm_1_1config.html#acba81635bfcc1d8d2f55bb5cb5b6a668" title="This option sets certain message meta information.">unicomm::config::message_info()</a>. It accepts five parameters where only the first is required. For request we have: first is a message type name (identifier), second tells whether reply is necessary to be waited for 1000 (third) milliseconds and the fourth is the vector of reply message type identifiers allowed, fifth is ommited and designates the default priority to be assigned to each instance of that message type if is not assigned yet.</p>
<p><div class="fragment"><div class="line">        .message_info(echo_request_message::static_name(), <span class="keyword">true</span>, </div>
<div class="line">          1000, list_of(echo_reply_message::static_name()))</div>
<div class="line">        .message_info(echo_reply_message::static_name())</div>
</div><!-- fragment --></p>
<p>It's also necessary to give unicomm the factory methods to create the messages defined above.</p>
<p><div class="fragment"><div class="line">        .message_factory</div>
<div class="line">          (</div>
<div class="line">            message_base::factory_type()</div>
<div class="line">              (uni_echo::echo_request_message::static_name(), </div>
<div class="line">                &amp;unicomm::create&lt;uni_echo::echo_request_message&gt;)</div>
<div class="line">              (uni_echo::echo_reply_message::static_name(), </div>
<div class="line">                &amp;unicomm::create&lt;uni_echo::echo_reply_message&gt;)</div>
<div class="line">          )</div>
</div><!-- fragment --></p>
<p>Next lines setup ssl specific parameters.</p>
<p><div class="fragment"><div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef UNICOMM_SSL</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">        .ssl_client_verity_fn(<span class="stringliteral">&quot;../ssl/ca.pem&quot;</span>)</div>
<div class="line">        .ssl_server_key_password(<span class="stringliteral">&quot;test&quot;</span>)</div>
<div class="line">        .ssl_server_cert_chain_fn(<span class="stringliteral">&quot;../ssl/server.pem&quot;</span>)</div>
<div class="line">        .ssl_server_key_fn(<span class="stringliteral">&quot;../ssl/server.pem&quot;</span>)</div>
<div class="line">        .ssl_server_dh_fn(<span class="stringliteral">&quot;../ssl/dh512.pem&quot;</span>)</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#endif // UNICOMM_SSL</span></div>
<div class="line"><span class="preprocessor">    );</span></div>
</div><!-- fragment --></p>
<p>Eventually we call <a class="el" href="namespaceunicomm.html#a47f6fa9a833c3f1f2a5140c2dcd1842e" title="Sets up binary message format to be used by the configuration.">unicomm::set_binary_message_format()</a> that sets up specific decoders and encoders.</p>
<p><div class="fragment"><div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="namespaceunicomm.html#a47f6fa9a833c3f1f2a5140c2dcd1842e" title="Sets up binary message format to be used by the configuration.">set_binary_message_format</a>(conf);</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<h1><a class="anchor" id="echo_main_section"></a>
Main</h1>
<p>Let's use the above defined stuff.</p>
 <div class="fragment"><div class="line"><span class="preprocessor">#if defined (UNI_WIN)</span></div>
<div class="line"><span class="keywordtype">int</span> _tmain(<span class="keywordtype">int</span> argc, _TCHAR* argv[])</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv)</div>
<div class="line"><span class="preprocessor">#endif // UNI_WIN</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    po::variables_map vm  = handle_command_line(argc, argv);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; host    = vm[<span class="stringliteral">&quot;host&quot;</span>].as&lt;<span class="keywordtype">string</span>&gt;();</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; port    = vm[<span class="stringliteral">&quot;port&quot;</span>].as&lt;<span class="keywordtype">string</span>&gt;();</div>
<div class="line">    <span class="keywordtype">size_t</span> threads        = vm[<span class="stringliteral">&quot;threads&quot;</span>].as&lt;<span class="keywordtype">size_t</span>&gt;();</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (threads &lt; 1) { threads = 1; }</div>
<div class="line">    <span class="keywordflow">if</span> (threads &gt; 10) { threads = 10; }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> tcp::resolver::query q(host, lexical_cast&lt;string&gt;(port));</div>
<div class="line">    <a class="code" href="classunicomm_1_1host__resolver.html" title="Host resolving helper.">unicomm::host_resolver</a> resolver = <a class="code" href="namespaceunicomm.html#a22eef6ac4a259c921fe603ebde6a0907" title="Resolves specified host name or address.">unicomm::resolve_host</a>(q);</div>
</div><!-- fragment --></p>
<p>Then we either start server or client.</p>
<p><div class="fragment"><div class="line"></div>
<div class="line">    <span class="keywordflow">if</span> (<span class="keyword">const</span> <span class="keywordtype">bool</span> is_server = vm.count(<span class="stringliteral">&quot;client&quot;</span>) == 0)</div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classunicomm_1_1config.html" title="Unicomm configuration storage class.">unicomm::config</a>&amp; config = uni_echo::config()</div>
<div class="line">        .<a class="code" href="classunicomm_1_1config.html#abe34031112411b5e67bc3fc122a576ea" title="Returns session factory object.">session_factory</a>(&amp;<a class="code" href="namespaceunicomm.html#aeb7343811ca329b13f868f7c3a44ed26" title="Default creator function, can be used with the factory.">uni_echo::server_session_type::create</a>)</div>
<div class="line">        .endpoint(*resolver.<a class="code" href="classunicomm_1_1host__resolver.html#a7bce861a7de105f53b2fd2382fb240d4" title="Returns iterator to the first resolved endpoint.">begin</a>());</div>
<div class="line"></div>
<div class="line">      server_loop(config, threads);</div>
<div class="line">    } <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">bool</span> is_infinite   = vm[<span class="stringliteral">&quot;req-number&quot;</span>].as&lt;<span class="keywordtype">size_t</span>&gt;() == 0;</div>
<div class="line">      <span class="keyword">const</span> <span class="keywordtype">size_t</span> clients_num = vm[<span class="stringliteral">&quot;client&quot;</span>].as&lt;<span class="keywordtype">size_t</span>&gt;();</div>
<div class="line"></div>
<div class="line">      <span class="keyword">const</span> <a class="code" href="classunicomm_1_1config.html" title="Unicomm configuration storage class.">unicomm::config</a>&amp; config = uni_echo::config()</div>
<div class="line">        .<a class="code" href="classunicomm_1_1config.html#abe34031112411b5e67bc3fc122a576ea" title="Returns session factory object.">session_factory</a>(boost::bind(&amp;<a class="code" href="namespaceunicomm.html#aeb7343811ca329b13f868f7c3a44ed26" title="Default creator function, can be used with the factory.">uni_echo::client_session_type::create</a>, _1, </div>
<div class="line">          uni_echo::client_session_params(request_list(vm), is_infinite, clients_num)))</div>
<div class="line">        .endpoint(*resolver.<a class="code" href="classunicomm_1_1host__resolver.html#a7bce861a7de105f53b2fd2382fb240d4" title="Returns iterator to the first resolved endpoint.">begin</a>());</div>
<div class="line"></div>
<div class="line">      client_loop(config, threads);</div>
<div class="line">    }</div>
<div class="line">  } </div>
<div class="line">  <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e)</div>
<div class="line">  {</div>
<div class="line">    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;An error occurred: &quot;</span> &lt;&lt; e.what() &lt;&lt; endl;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">  {</div>
<div class="line">    cout &lt;&lt; endl &lt;&lt; <span class="stringliteral">&quot;An error occurred: Unknown error&quot;</span> &lt;&lt; endl;</div>
<div class="line"></div>
<div class="line">    BOOST_ASSERT(!<span class="stringliteral">&quot;Unknown error&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> EXIT_FAILURE;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> EXIT_SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --></p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespaceunicomm.html#a0963614efee4ab2b6fbe57f6281c9dd7" title="Loads unicomm configuration from smart::data::complex xml format file.">unicomm::load_from_complex_xml()</a>.</dd></dl>
<h1>Sources</h1>
<p><a class="el" href="echo_sources_page.html">Source code</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Jun 1 2013 01:38:53 by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.2 </li>
  </ul>
</div>
</body>
</html>
